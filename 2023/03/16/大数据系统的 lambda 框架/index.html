<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>大数据系统的 lambda 框架 | 小灰灰在青青草原</title><meta name="author" content="Xinrihui"><meta name="copyright" content="Xinrihui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="大数据系统的 lambda 框架1.介绍1.大数据系统的特性：鲁棒性和容错性（容忍人为错误）低延迟读取和更新可扩展性通用性：支持大部分应用延展性：易于增加新功能ad hoc 查询最少维护：选择实现复杂性最低的组件可调试性：在批处理层做重新计算2.传统的全增量架构（应用对数据的修改 都立刻反映在数据库中）的问题：在线合并（eg. hbase 的 compact）带来的复杂性，而在lambda框">
<meta property="og:type" content="article">
<meta property="og:title" content="大数据系统的 lambda 框架">
<meta property="og:url" content="https://xinrihui.github.io/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="小灰灰在青青草原">
<meta property="og:description" content="大数据系统的 lambda 框架1.介绍1.大数据系统的特性：鲁棒性和容错性（容忍人为错误）低延迟读取和更新可扩展性通用性：支持大部分应用延展性：易于增加新功能ad hoc 查询最少维护：选择实现复杂性最低的组件可调试性：在批处理层做重新计算2.传统的全增量架构（应用对数据的修改 都立刻反映在数据库中）的问题：在线合并（eg. hbase 的 compact）带来的复杂性，而在lambda框">
<meta property="og:locale">
<meta property="article:published_time" content="2023-03-16T01:22:30.000Z">
<meta property="article:modified_time" content="2023-03-16T01:23:47.662Z">
<meta property="article:author" content="Xinrihui">
<meta property="article:tag" content="lambda 框架">
<meta property="article:tag" content="批处理">
<meta property="article:tag" content="流处理">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xinrihui.github.io/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '大数据系统的 lambda 框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-16 09:23:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="小灰灰在青青草原" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小灰灰在青青草原</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">大数据系统的 lambda 框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-03-16T01:22:30.000Z" title="Created 2023-03-16 09:22:30">2023-03-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-16T01:23:47.662Z" title="Updated 2023-03-16 09:23:47">2023-03-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97/">分布式数据库系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="大数据系统的 lambda 框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.6.4 (470194)"/><meta name="author" content="735407517@qq.com"/><meta name="created" content="2023-03-14 07:51:11 +0000"/><meta name="source" content="yinxiang.superNote"/><meta name="updated" content="2023-03-16 01:17:25 +0000"/><title>大数据系统的 lambda 框架</title></head><body><h1>1.介绍</h1><div><br/></div><div><span style="font-size: 12pt;">1.大数据系统的特性：</span></div><ul><li><div><span style="font-size: 12pt;">鲁棒性和容错性（容忍人为错误）</span></div></li><li><div><span style="font-size: 12pt;">低延迟读取和更新</span></div></li><li><div><span style="font-size: 12pt;">可扩展性</span></div></li><li><div><span style="font-size: 12pt;">通用性：支持大部分应用</span></div></li><li><div><span style="font-size: 12pt;">延展性：易于增加新功能</span></div></li><li><div><span style="font-size: 12pt;">ad hoc 查询</span></div></li><li><div><span style="font-size: 12pt;">最少维护：选择实现复杂性最低的组件</span></div></li><li><div><span style="font-size: 12pt;">可调试性：在批处理层做重新计算</span></div></li></ul><div><br/></div><div><span style="font-size: 12pt;">2.传统的全增量架构（应用对数据的修改 都立刻反映在数据库中）的问题：</span></div><ul><li><div><span style="font-size: 12pt;">在线合并（eg. hbase 的 compact）带来的复杂性，而在lambda框架中，主数据库无需合并</span></div></li><li><div><span style="font-size: 12pt;">高可用性（CAP 中的A）和一致性（CAP 中的C）的矛盾</span></div></li><li><div><span style="font-size: 12pt;">无法容忍人为错误：数据库中的表就是被业务人员改坏了；而lambda框架 采用异步架构，对数据库的修改先放入一个队列中，并不直接修改数据库</span></div></li></ul><div><br/></div><div><span style="font-size: 12pt;">3.lambda架构在 准确率， 延迟 和 吞吐量 上具有优势</span></div><div><br/></div><div><span style="font-size: 12pt;">4.整体架构</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/2346C865-D420-48CD-829C-B902F38D3130.png" height="50%" width="80%"/><div><br/></div><ul><li><div><span style="font-size: 12pt;">批处理层</span></div></li></ul><div><span style="font-size: 12pt;">存储主数据集并不断计算<span style="background-color: #fff199;">批处理视图</span> <span style="background-color: #fff199;">（类似数据仓库的 公共汇总层 DWS）；</span></span></div><div><span style="font-size: 12pt;">不需要支持随机写主数据集；</span></div><div><span style="font-size: 12pt;">高延时，没有最新的数据</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">服务层</span></div></li></ul><div><span style="font-size: 12pt;">随机读取批处理视图并更新批处理视图，不需要支持随机写批处理视图；</span></div><div><br/></div><div><span style="font-size: 16px;">eg. 批处理视图 </span></div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:570px;" width="570px"><colgroup><col style="width: 190px;"/><col style="width: 190px;"/><col style="width: 190px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>事实明细表</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>汇总事实表（<span style="background-color: #fff199;">批处理视图</span>）</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="background-color: #fff199;">T日</span>查询</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>.....</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-3日 商品A 销售总个数为5</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;" rowspan="6"><div>最近3日的</div><div>商品A 销售总个数为：</div><div>5+5+6 = 16</div><div>（T日的数据批处理视图没有，因此存在延迟）</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><br/></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-2日 商品A 销售总个数为5</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-1日 用户1 买了商品A  1件</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;" rowspan="4"><div>T-1日 商品A 销售总个数为1+2+4-1=6</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-1日 用户2 买了商品A  2件</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-1日 用户3 买了商品A  4件</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-1日 用户3 <span style="background-color: #fff199;">退了</span>商品A  1件</div></td></tr></tbody></table><div><br/></div><ul><li><div><span style="font-size: 12pt;">速度层</span></div></li></ul><div><span style="font-size: 12pt;">类似于批处理层，但是只对最新到来的、来不及进行批处理的数据生成视图；</span></div><div><span style="font-size: 12pt;">速度层做增量计算，不像批处理层要重新计算；</span></div><div><span style="font-size: 12pt;">速度层需要支持随机读和随机写；</span></div><div><span style="font-size: 12pt;">一旦数据通过批处理层到服务层，速度层中的实时视图就可以丢弃；</span></div><div><span style="font-size: 12pt;">速度层支持随机写，因此比批处理层复杂，这体现了 复杂性隔离；</span></div><div><span style="font-size: 12pt;">要得到最新的（低延迟）并且完整的快照需要同时查询批处理视图（历史数据）和实时视图（当前数据）。批处理层采用精确算法（全量计算），速度层采用近似算法（增量计算）</span></div><div><br/></div><div><span style="font-size: 16px;">eg.实时视图</span></div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:570px;" width="570px"><colgroup><col style="width: 190px;"/><col style="width: 190px;"/><col style="width: 190px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="background-color: #fff199;">批处理视图</span></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="background-color: #fff199;">实时视图</span></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="background-color: #fff199;">T日</span>查询</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-3日 商品A 销售总个数为5</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;" rowspan="5"><div>从T日 开始 </div><div>商品A 销售总个数为3</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;" rowspan="5"><div>商品A 销售总个数为：</div><div>（5+5+6)+3 = 16+3 =19</div><div><br/></div><div>来自实时视图的结果可能是不准确的，例如T日有用户退货后，那么销售个数就不是3了；</div><div><br/></div><div>但是这也没关系，因为当今天过去后，T日的数据就成为历史，明天来看T日的数据已经是准确的了</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>T-2日 商品A 销售总个数为5</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;" rowspan="3"><div>T-1日 商品A 销售总个数为6</div></td></tr><tr/><tr/></tbody></table><div /><div><br/></div><div><span style="font-size: 16px;">5.数据仓库架构</span></div><div><br/></div><ul><li><div><span style="font-size: 16px;">离线数据仓库</span></div></li></ul><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/C356B2F3-8B86-4BC5-AB75-29C356244C72.png" height="50%" width="80%"/><ul><li><div><span style="font-size: 16px;">实时数据仓库</span></div></li></ul><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/F1988529-ECE5-4FF0-8773-8A65703B4136.png" height="50%" width="80%"/><div><br/></div><h1>2.数据模型</h1><div><br/></div><div><span style="font-size: 12pt;">1.数据的关键属性：</span></div><ul><li><div><span style="font-size: 12pt;">原始性</span></div></li></ul><div><span style="font-size: 12pt;">数据越原始，粒度越细，包含的信息量越大， 未来可以向数据问的问题就越多（很难提前想好要问的问题）</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">不可变性</span></div></li></ul><div><span style="font-size: 12pt;">一条新的记录进来后，我们不像关系数据库那样更新表，而是不断添加（append）最新的记录来表示更改的信息。</span></div><div><span style="font-size: 12pt;"><span style="font-weight: bold;">这样可减少建立索引带来的复杂性，并且容忍人为错误</span></span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">真实性 </span></div></li></ul><div><span style="font-size: 12pt;">根据策略对历史数据进行删除（合并），例如 每年每人只保留一个地理位置信息 而不是 所有的地理位置信息都保留</span></div><div><br/></div><div><span style="font-size: 12pt;">2.<span style="background-color: #fff199;">基于事实</span>的数据模型，事实模型具有：</span></div><ul><li><div><span style="font-size: 12pt;"> <span style="font-weight: bold;">原子性</span></span></div></li></ul><div><span style="font-size: 16px;">事实不能再进一步被细分，并且带上时间戳</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;"><span style="font-weight: bold;">可识别性（唯一性）</span></span></div></li></ul><div><span style="font-size: 16px;">如果遇到两个相同的 页面浏览记录即事实（同个时间，同个ip访问同个url ），那么我们需要添加一个区分的标记（为每个页面浏览附上一个随机数）</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">3.<span style="font-weight: bold;">对于传统的关系型数据库，查询在数据存储层上执行的，需要权衡查询效率和数据一致性。而lambda架构中，数据的查询和存储是分离的</span>。</span></div><div><span style="font-size: 12pt;">在批处理层，为了实现数据的高效存储，采用<span style="background-color: #fff199;">规范化</span>的表存储数据（每条信息值存储在一个地方，这保证了一致性，但是查询时需要大量的连接操作，代价很高，影响查询效率）。</span></div><div><span style="font-size: 12pt;">而在服务层，采用<span style="background-color: #fff199;">非规范</span>的模式，冗余的存储，追求高效查询。</span></div><div><br/></div><div><span style="font-size: 12pt;">4.使用 半结构化的文本格式 ，例如json ，由于非常灵活，任何数据都能写入主数据集 导致 数据损坏；</span></div><div><span style="font-size: 12pt;">为了解决这个问题，我们采用序列化框架（thrift）来存储数据，同时它还给系统带来了可演化性。</span></div><div><br/></div><div><span style="font-size: 12pt;">5.序列化框架（thrift）的局限性</span></div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:380px;" width="380px"><colgroup><col style="width: 190px;"/><col style="width: 190px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>会检查</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>无法检查</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="font-size: 14px;">必填的字段是否存在</span></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>字段的取值范围是否合法 </div><div>eg. 年龄必须 &gt;0 </div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="font-size: 14px;">字段的类型是否符合预期</span></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><br/></div></td></tr></tbody></table><div><br/></div><div><br/></div><h1>3.批处理层</h1><div><br/></div><h2>数据存储</h2><div><br/></div><div><span style="font-size: 12pt;">1.支持合并操作，解决HDFS 的小文件问题；</span></div><div><br/></div><div><span style="font-size: 12pt;">2.支持分区和压缩。HDFS中的数据集的维护，包括追加 分区 和 合并都非常繁琐。而Pai 使得这些操作对用户透明，我们可以专注于对记录进行如何处理，而不是存储记录的细节</span></div><div><br/></div><h2>数据计算</h2><div><br/></div><div><span style="font-size: 12pt;">1.在批处理层，对主数据集进行计算，生成中间结果数据即批处理视图，该视图由服务层加载和索引。</span></div><div><br/></div><div><span style="font-size: 12pt;">eg.在给定的时间范围内，查询某个URL的游览量。</span></div><div><span style="font-size: 12pt;">可以先 预先计算 每个URL每个小时的游览量，当查询到来了之后，我们把查询范围内每个小时的游览量进行求和 即可</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/D3E4EEA6-A8F8-4C57-B2EB-42C34C3708D1.png" height="50%" width="80%"/><div><br/></div><div><span style="font-size: 12pt;">2.全量（重新）计算 和 增量计算</span></div><div><br/></div><ul><li><div><span style="font-size: 16px;">全量计算</span></div></li></ul><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/24154F01-5283-4DCD-96BF-4D131B42B62B.png" height="50%" width="80%"/><div><br/></div><ul><li><div><span style="font-size: 16px;">增量计算</span></div></li></ul><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/FFA2C330-D5C7-4665-973F-3B56F7FACE72.png" height="50%" width="80%"/><div><br/></div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:791px;" width="791px"><colgroup><col style="width: 218px;"/><col style="width: 223px;"/><col style="width: 350px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>eg</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>全量计算的批处理视图</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>增量计算的批处理视图</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>给定时间范围内（最近24小时内）URL的平均页面浏览量（ page view, PV）</div><div>单位： 次数/ 小时</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>url -&gt; 平均页面浏览量</div><div><br/></div><div><a target="_blank" rel="noopener" href="http://www.baidu.com" rev="en_rl_none">www.baidu.com</a> -&gt; 1000次/小时</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>因为要增量的更新平均页面浏览量，还需要知道之前用于计算平均页面浏览量的记录总数</div><div><br/></div><div>url -&gt; 平均页面浏览量，页面浏览总数</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>URL的独立访客数量</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/D979F12D-9364-48F6-867A-83862C360951.png" height="50%" width="80%"/><div><br/></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/2231FBCE-086C-46C4-9C17-C20579E2ED6A.png" height="50%" width="80%"/><div>新数据来了之后要结合老的时图对访客id 进行去重，所以要记录 url 的所有访客的集合</div></td></tr></tbody></table><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:520px;" width="520px"><colgroup><col style="width: 140px;"/><col style="width: 190px;"/><col style="width: 190px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><br/></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="font-size: 14px;">全量计算</span></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="font-size: 14px;">增量计算</span></div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>实现</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="font-size: 14px;">丢弃原来的批处理视图，合并新数据到主数据集，然后对主数据集计算。</span></div><div><br/></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="font-size: 14px;">只使用新到来的数据和原有的批处理视图，然后更新批处理视图。</span></div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>优缺点</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div><span style="font-size: 14px;">简单，效率低，容错好</span></div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>复杂，效率高，容错差</div></td></tr></tbody></table><div><br/></div><div><span style="font-size: 12pt;">3.在传统的 MapReduce 中，逻辑和物理执行是紧密偶合的，我们将所有功能组织到一起导致了不良的工程实践，而模块化代码将导致资源使用情况不佳。因此，我们使用管道图，它使得我们只需要写出数据的处理流程，具体的优化交给管道图组件，其实 <span style="background-color: #FFF199;">Spark 也是一种管道图</span>。</span></div><div><br/></div><div><span style="font-size: 12pt;">4.内连接 的 MapReduce实现</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/96E21878-03E8-4F84-97D8-1E8AF22A854F.png" height="50%" width="80%"/><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/4743D22E-3671-4AA8-A06F-53BB847F288F.png" height="50%" width="80%"/><div><span style="font-size: 12pt;">5.管道图</span></div><div><span style="font-size: 12pt;">（1）单词计数，最后所有计数值再乘2</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/040ADA39-AED3-4343-8E61-8AE4582D588C.png" height="50%" width="80%"/><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">（2）管道图编译器，会将尽可能多的操作封装在 一个 map-reduce过程完成，这样IO是最少的。因此，编程的时候我可以将计算分解为多个步骤，而不担心性能问题。</span></div><div><br/></div><div><span style="font-size: 12pt;">（3）在聚合过程中，会先做部分聚合，然后合并部分结果得到最终结果，这样可节省IO。例如count操作，先计算每个节点的部分数据集的部分计数，然后发送这一计数到collecter，最后合成得到全部计数。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">6.生成批处理视图，可以使用不同的时间粒度进行汇总，从细到粗</span></div><div><span style="font-size: 12pt;">（1）小时粒度</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/78E7A2F4-B52D-401C-801E-F8759FB0F98C.png" height="50%" width="80%"/><div>（2）天，周，月粒度</div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/6DA709BA-C37B-41C6-8E49-936769C3C47C.png" height="50%" width="80%"/><div><span style="font-size: 16px;">不但汇总每小时的 页面浏览量，还聚合 每天，每周和每个月的页面浏览量，这样在 做大时间范围的查询的时候，可以减少查询的数量。</span></div><div><br/></div><div><span style="font-size: 16px;">eg. 计算 3月3日上午 3点到 9月17日上午8点的页面浏览量</span></div><div><span style="font-size: 16px;">如果使用小时粒度，那么要检索并累加 4805条记录；</span></div><div><span style="font-size: 16px;">如果使用 小时，天，周，月粒度那么只需要检索 26条记录</span></div><div><span style="font-size: 12pt;"> </span></div><div><span style="font-size: 12pt;">7.在批处理工作流正在运行的时候，禁止新数据被插入到主数据集中，这样会导致生成的视图不一致，因此需要把新数据和主数据集进行隔离。</span></div><div><br/></div><div><span style="font-size: 12pt;">8.读取数据-&gt;数据处理-&gt;生成视图</span></div><div><br/></div><h1>4.服务层</h1><div><br/></div><div><span style="font-size: 12pt;">1.性能指标</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-weight: bold;">延迟</span>：响应单个查询所需要的时间（ 查询效率由最差的那一台机器决定，所以一个查询涉及的服务器越多，查询的总延迟越大）</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-weight: bold;">吞吐量</span>：给定时间可以服务的查询数量（集群的磁盘数量决定了每秒可以实现的磁盘寻道速度）</span></div><div><br/></div><div><span style="font-size: 12pt;">2.提升查询性能</span></div><div><br/></div><ul><li><div><span style="font-size: 16px;">索引</span></div></li></ul><div><span style="font-size: 12pt;">把一个 主键（例如URL）的所有信息收集在同一个分区进行存储，这样查询时只需要一次的磁盘寻道时间</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/FD7B9621-179B-4E7C-9808-6313895DC11F.png" height="50%" width="80%"/><ul><li><div><span style="font-size: 16px;">非规范化</span></div></li></ul><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:1164px;" width="1164px"><colgroup><col style="width: 575px;"/><col style="width: 589px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>规范化</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>非规范化</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/16B49B69-6441-46C5-B9F5-4155216E35CC.png" height="50%" width="80%"/></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/18CEEC87-B6AB-40C0-8C1B-50DC1CB85685.png" height="50%" width="80%"/></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>没有冗余数据</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>预先把多个表进行连接后得到的结果，这样冗余的存储可以提升查询性能（查询的时候不用再做join 了）；</div><div><span style="background-color: #FFF199;">类似数据仓库中 DWS 中的大宽表</span></div><div><br/></div></td></tr></tbody></table><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">3.服务层只需要<span style="font-weight: bold;">批量写</span>，而无需支持<span style="font-weight: bold;">随机写</span>。</span></div><div><br/></div><div><span style="font-size: 12pt;">随机写的复杂性：</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">在线压缩</span></div></li></ul><div><span style="font-size: 12pt;">压缩（hbase 中的compact操作即合并 storefile ，会把已经失效的数据删除）会占用集群过多资源，然后饿死需要资源的快速服务查询</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">同步读操作和写操作</span></div></li></ul><div><span style="font-size: 12pt;">写到一半的值不会被读取（事务隔离级别中的脏读）</span></div><div><br/></div><div><span style="font-size: 12pt;">4.可以从主数据集重新计算批处理视图，因此具有容错性</span></div><div><br/></div><div><span style="font-size: 12pt;">5.在服务层，根据查询来定制优化，包括使用非规范化的冗余数据，执行额外的聚合和转换。    </span></div><div><br/></div><div><br/></div><h1>5.速度层</h1><div><br/></div><div><span style="font-size: 16px;">1.速度层特性：</span></div><ul><li><div><span style="font-size: 12pt;">速度层弥补了 服务层的高延迟更新，允许访问最新的数据（T日0:00到当前时刻的数据）</span></div></li><li><div><span style="font-size: 12pt;">速度层支持随机写</span></div></li><li><div><span style="font-size: 12pt;">速度层基于增量计算，只负责未在服务层中的数据，数据规模小</span></div></li><li><div><span style="font-size: 12pt;">速度层视图是暂时的，新数据一旦被服务层视图获取就可以丢弃速度层的视图（T日过去，进入T+1日，T日的数据变为历史数据进入主数据集），因此速度层视图的错误都可以被服务层纠正</span></div></li></ul><div><br/></div><div><span style="font-size: 12pt;">2.两种策略</span></div><div><span style="font-size: 12pt;">（1）对所有近期数据采用和批处理一样的方法生成视图（延时在分钟级别）</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/5A9B4C76-A647-423D-8AC9-743038B6ED43.png" height="50%" width="80%"/><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">（2）采用增量的方法，即在原来的基础上更新视图（低延时）</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/064E5F32-D13C-4B26-9FD8-95DADC69D6F2.png" height="50%" width="80%"/><div><br/></div><div><span style="font-size: 12pt;">3.更新策略</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">同步更新</span></div></li></ul><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/0E3EFF33-FC30-46EC-974F-B3594B24B69E.png" height="50%" width="80%"/><div><span style="font-size: 16px;">客户端直接与数据库通信并阻塞直到更新完成；</span></div><div><span style="font-size: 12pt;">无法纠错，不能保证所有请求都被处理；</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;"><span style="background-color: #FFF199;">异步更新</span></span></div></li></ul><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/319E1EA6-9414-4A6C-AF8F-9D39C0BA0A7B.png" height="50%" width="80%"/><div><span style="font-size: 12pt;">更新请求放在队列中，获得更好的吞吐量（从队列中读取多个消息并向数据库批量提交更新）和峰值高峰（削峰限流）的管理</span></div><div><br/></div><div><span style="font-size: 12pt;">4.实现最终一致性：对于每一个副本，如果接收到更新，则版本号+1，网络分区结束后进行合并的时候选版本号最大的</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/97ED9320-6262-452A-8E58-4F965467116C.png" height="50%" width="80%"/><div><span style="font-size: 12pt;">5.过期数据的删除</span></div><div><br/></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/C9FB9E07-9818-483F-BF6B-2FC9D8DF2703.png" height="50%" width="80%"/><div><br/></div><div><span style="font-size: 12pt;">5.速度层采用的增量处理，由于无法一次性查看所有数据，所以只能使用近似算法以实现低延迟的处理</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-family: 微软雅黑, 宋体, Arial;"><span style="color: rgb(0, 0, 0);">6.工作进程挂了时的两种恢复方法：</span></span></span></div><ul><li><div><span style="font-size: 12pt;"><span style="font-family: 微软雅黑, 宋体, Arial;"><span style="color: rgb(0, 0, 0);">更新时，同时将更新内容写入日志 </span></span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-family: 微软雅黑, 宋体, Arial;"><span style="color: rgb(0, 0, 0);">在有且仅有一次的模型下，通过周期性的设置检查点来保存内存状态</span></span></span></div></li></ul><div><br/></div><h2>队列</h2><div><br/></div><div><span style="font-size: 12pt;">1.分布式系统中的<span style="font-weight: bold;">幂等性</span></span></div><div><br/></div><div><span style="font-size: 12pt;">系统拆为多个微服务，如果一个服务迟迟不响应，那么客户端会多次请求，我们希望用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-family: 微软雅黑, 宋体, Arial;"><span style="color: rgb(0, 0, 0);">举个最简单的例子，那就是支付，用户购买商品使用约支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了。</span></span></span></div><div><br/></div><div><span style="font-size: 12pt;">2.在异步结构中</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/319E1EA6-9414-4A6C-AF8F-9D39C0BA0A7B.png" height="50%" width="80%"/><ul><li><div><span style="font-size: 12pt;"><span style="font-weight: bold;">单消费者队列</span></span></div></li></ul><div><span style="font-size: 12pt;">多个应用程序使用相同的流，只能将他们封装在相同的消费者队列中，这样程序没有隔离性，而为每一个应用程序维护一个队列的成本太高；</span></div><div><br/></div><div><span style="font-size: 16px;">消息一旦被确认成功就会被删除，无法进行回放，一个失败的事件会导致事件流被乱序处理（如果流被并行的消费并且一个事件失败）</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;"><span style="font-weight: bold;">多消费者队列</span></span></div></li></ul><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/828E07AA-0828-4576-BA6F-0166AFD5DE89.png" height="50%" width="80%"/><div><span style="font-size: 16px;">允许 回放流 和 回放自故障点以来的任何事件，确保能够按照事件的起始顺序来处理事件</span></div><div><span style="font-size: 16px;">（eg. <span style="background-color: #FFF199;">Kafka </span>）</span></div><div><br/></div><h2>流处理</h2><div><br/></div><h3>1.流处理模式</h3><div><br/></div><div><span style="font-size: 12pt;">在传入事件给多消费者队列后，接下来就是处理这些事件并更新实时视图，这一过程叫做流处理。</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/F5CE30DA-8AE3-48D8-AD68-B82D7F96CCAB.png" height="50%" width="80%"/><div><br/></div><ul><li><div><span style="font-size: 12pt;"><span style="font-weight: bold;">一次一个流处理模型</span></span></div></li></ul><div><span style="font-size: 12pt;">storm 以一次一个元组的方式来处理元组，但是代码可以跨集群并行运行。使得我们可以专注于业务逻辑，把序列化、消息传递、任务发现和容错交给storm。storm 模型是将流转换为新的流，然后更新数据库。</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/7CA588AE-73F3-4630-9A57-4B7ADF53C000.png" height="50%" width="80%"/><div><span style="font-size: 12pt;">                    <span style="font-weight: bold;">kafka                                              storm                                              cassandra</span></span></div><div><br/></div><div><br/></div><ul><li><div><span style="font-size: 12pt;"><span style="font-weight: bold;">微批量流处理模型</span></span></div></li></ul><div><span style="font-size: 12pt;"><span style="background-color: #FFF199;">通过延迟（&lt;1s）换取精确性</span>，每一个批量的数据按照严格的次序进行处理（通过在状态中保存批量ID，它可以检测该批量是否已经被处理过，因为每个批量都有唯一的ID且严格按照先后顺序执行，ID每次回放总是一样的，在批量的内部的元组可以并行处理），能够在操作出现错误后实现<span style="background-color: #FFF199;">有且只有一次</span>的语义。</span></div><div><br/></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/B7DB3B08-4ED1-42F5-AAB2-2E3A5CF03725.png" height="50%" width="80%"/><div><br/></div><h3>2.实现一次一个流处理模型</h3><div><br/></div><ul><li><div><span style="font-size: 16px;"><b>队列+工作节点</b></span></div></li></ul><div><span style="font-size: 16px;">将处理操作分到工作节点中，并在它们之前放置队列。如果一个工作节点失败或重启，他可以通过读取他的队列从上次中断处继续。</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/4200CE60-F35E-442D-887D-152CF135426E.png" height="50%" width="80%"/><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:519px;" width="519px"><colgroup><col style="width: 155px;"/><col style="width: 364px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>缺陷</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>描述</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>构建困难</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>大部分代码致力于完成序列化和反序列化通过队列完成的对象，连接工作节点持的路由逻辑，在集群上部署工作节点的指令</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>容错性差</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>对队列进行分区带来的容错性变差</div></td></tr></tbody></table><div><br/></div><ul><li><div><span style="font-size: 16px;"><b>更高层的抽象：Storm框架</b></span></div></li></ul><div><span style="font-size: 16px;">将整个流处理管道表达为一个计算图，也称拓扑。在之前的 <b>队列+工作节点 </b>方式中我们要为图中的每个节点编程并手动的连接它们。而 storm 是将一个整体的程序部署到集群上。</span></div><div><span style="font-size: 16px;">序列化，消息传递，任务发现和容错都交给框架来处理，并且是低延迟的（<span style="background-color: #FFF199;">&lt; 10ms</span>）。</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/6D29AC05-4B6B-4B37-8114-41558F5C01F7.png" height="50%" width="80%"/><div><span style="font-size: 16px;">1.流分组</span></div><div><span style="font-size: 16px;">类似批处理系统中的分区，流系统也需要确定 当前元组流向下层的哪个 Bolt进行处理</span></div><table style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:582px;" width="582px"><colgroup><col style="width: 190px;"/><col style="width: 392px;"/></colgroup><tbody><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>随机分组</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>字段分组</div></td></tr><tr><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>随机，均匀地将元组分配给所有的消费者，来分散处理负载</div></td><td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"><div>类似哈希分区，</div><div>slot = hash(元组字段的一个子集) % 消费者Bolt 的数量</div><div><br/></div></td></tr></tbody></table><div><br/></div><div><span style="font-size: 16px;">2.</span><span style="font-size: 12pt;">计算 word count</span></div><div><br/></div><div><span style="font-size: 16px;">下图中 <b>word-splitter Bolt  </b>将句子转换为单词流，然后 <b>word-count Bolt</b> 消费这些单词来进行计数；</span></div><div><span style="font-size: 16px;"><b>word-splitter Bolt </b>和<b> word-count Bolt </b>之间采用字段分组，保证相同的单词被送到相同的 Bolt中。</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/677DE5B5-FB0E-41F1-B7E9-617AF5F59C76.png" height="50%" width="80%"/><div><span style="font-size: 16px;">word-splitter Bolt 代码如下：</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/B07D3A96-F052-46DD-99A4-48E7F12B6C9F.png" height="50%" width="80%"/><div><br/></div><div><span style="font-size: 16px;">word-count Bolt 代码如下：</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/077A10B6-8564-4794-98DE-68F81C817511.png" height="50%" width="80%"/><div><span style="font-size: 16px;">可见，我们不需要关心 如何发送元组，如何序列化元组，这些都交给框架去完成</span></div><div><br/></div><div><span style="font-size: 16px;">3.</span><span style="font-size: 12pt;">利用位运算，storm 只需要少量的内存 即可以追踪 DAG（见下图） 中的所有 元组，这样可以追踪失败的元组 并在流处理期间重启加工，即做到了 “<span style="background-color: #FFF199;">至少一次</span>”的语义保证。</span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/FE3C84DF-580E-4F40-8C85-014E5208C69D.png" height="50%" width="80%"/><div><br/></div><div><br/></div><h3>3.语义保障</h3><div><br/></div><div><span style="font-size: 12pt;">按照每条记录被完全处理的次数 分为:</span></div><div><br/></div><div><span style="font-size: 12pt;">(1) 至多处理一次</span></div><div><span style="font-size: 12pt;">保障每条记录  不被完全处理(中途丢失)，或被完全处理一次，不会出现重复现象。该处理语义适用于对数据处理完整性要求不高的场景，例如通过微博内容预测话题趋势，少量微博记录的丢失不会对话题趋势产生太大影响。以推送(push)方式获取数据可以较容易实现至多处理一次的语义</span></div><div><br/></div><div><span style="font-size: 12pt;">(2) 至少处理一次</span></div><div><span style="font-size: 12pt;">系统保障每条记录一定会被完全处理，但可能出现重复处理现象．通常该语义可以在处理路径上每个计算单元都支持 <span style="font-weight: bold;">幂等操作</span> 的场景下使用。为实现该语义，通常需要系统 对流入的数据进行持久化存储(如SparkStreaming平台)，或依赖于可重复获取数据的可靠数据源(如Kafka分布式队列)，当系统检测到处理失败或超时的情况能够进行数据重发。这种做法本质上是以牺牲效率为代价，克服了流数据“一经处理就很难再次获取的”特性。</span></div><div><br/></div><div><span style="font-size: 12pt;">(3) 精确处理一次</span></div><div><span style="font-size: 12pt;">最严格的一种。它需要系统保障对每个记录完全处理且仅一次，处理后的状态更新往往会反映到可靠的持久化存储介质中。一个典型的应用例子是wordCount问题。对于每条记录中的句子需要精确统计单词频数并进行累加，重复或遗漏都将导致最终结果不准确。为保证该语义，流处理系统需要“记住”哪些数据已经被完全处理。</span></div><div><br/></div><div><span style="font-size: 12pt;">Storm的Trident所采用的一种方法是在保证至少处理一次语义的前提下，将数据流划分为批次，并分别赋予它们唯一的ID。处理完成后，Trident负责将对应批次产生的状态更新和ID以一次原子操作写入某个可靠的存储介质中。当遇到超时或故障需要进行数据重发时，Trident会以某种策略生成与之前完全相同的批次数据和ID，这样如果出现重复提交，可以根据检测ID决定是否接受。</span></div><div><br/></div><div><span style="font-size: 12pt;">（4）精确处理一次 并 保证顺序</span></div><div><span style="font-size: 12pt;">对于一些存在先后顺序(如发生时间)的数据，系统需要在提供精确处理一次语义的前提下，对一些持久化状态相关冲突操作的执行顺序提供一定保障。基本思路是将数据划分为批次，每批次数据所引发的操作和状态更新看作一次“事务”进行．如上文提到的Trident，它采用了一种较为极端的策略，即认为所有批次的状态更新都是存在冲突的，因此只允许每个批次严格按照先后顺序串行执行。</span></div><div><span style="font-size: 12pt;">这些应对措施都是为保证分布式并行处理结果的正确性和一致性。若想精确实现这一目标，需要参照传统关系数据库，首先提供可持久化的原子操作(需要存储策略支持)，然后在此基础上对各计算单元实例的冲突依赖关系进行细粒度分析，制定并行策略。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-weight: bold;">幂等操作</span></span></div><div><span style="font-size: 12pt;">添加一个元素到集合中，无论执行多少次操作，得到的结果相同。<span style="background-color: #FFF199;">因此如果操作是幂等的，那么我们只需要做到至少一次语义</span>。而对于计数操作（word count），它明显不是 幂等的 ，所以我们期望是有且仅有一个语义。</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><h1><span style="font-family: 微软雅黑, 宋体, Arial;">6.总结和深入</span></h1><div><br/></div><h2>批处理中的增量计算</h2><div><br/></div><div><span style="font-size: 12pt;"><span style="font-family: 微软雅黑, 宋体, Arial;"><span style="color: rgb(0, 0, 0);">生日推理问题：</span></span></span></div><div><br/></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/C0425F98-2E06-4A54-A123-FD696BEFD8F2.png" height="50%" width="80%"/><div><br/></div><div><span style="font-size: 12pt;"><span style="font-family: 微软雅黑, 宋体, Arial;">批处理层运行时，重新计算每一个人的生日很浪费。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-family: 微软雅黑, 宋体, Arial;"><span style="font-weight: bold;">部分重新计算</span>：新批量数据中，找出有新年龄样本的人；在主数据集中检索他们（见下图，布隆过滤器可以过滤掉大部分的主数据集，但是由于误报，会渗入一些错误的数据，做join可以清除他们）；重新计算他们的生日；合并新计算的结果到服务层视图（速度层和服务层的视图应该结构化，以帮助合并）</span></span></div><img src="/Resources/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6.resources/A24E15F1-ADA9-4FA9-AFC8-7CAF8110B95B.png" height="50%" width="80%"/><div><br/></div><div><span style="font-size: 16px;"><b>引用</b></span></div><div><span style="font-size: 16px;">1.《大数据系统构建：可扩展实时系统构建原理与最佳实践》</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io">Xinrihui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/">https://xinrihui.github.io/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lambda-%E6%A1%86%E6%9E%B6/">lambda 框架</a><a class="post-meta__tags" href="/tags/%E6%89%B9%E5%A4%84%E7%90%86/">批处理</a><a class="post-meta__tags" href="/tags/%E6%B5%81%E5%A4%84%E7%90%86/">流处理</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">分布式系统综述</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xinrihui</div><div class="author-info__description">一个计算机民间爱好者的关于算法，分布式系统和机器学习的笔记，欢迎大佬拍砖交流～。笔者曾在微软亚洲研究院实习，参与国家重点研发计划，兴趣为分布式系统和机器学习。转载请注明引用（应该也没人看 ==），邮箱 xinrihui@outlook.com</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinrihui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">2.数据模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">3.批处理层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">数据存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">数据计算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">4.服务层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">5.速度层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.1.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.2.</span> <span class="toc-text">流处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.流处理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.实现一次一个流处理模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.语义保障</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">6.总结和深入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.1.</span> <span class="toc-text">批处理中的增量计算</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/" title="大数据系统的 lambda 框架"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据系统的 lambda 框架"/></a><div class="content"><a class="title" href="/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/" title="大数据系统的 lambda 框架">大数据系统的 lambda 框架</a><time datetime="2023-03-16T01:22:30.000Z" title="Created 2023-03-16 09:22:30">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" title="分布式系统综述"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式系统综述"/></a><div class="content"><a class="title" href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" title="分布式系统综述">分布式系统综述</a><time datetime="2023-03-10T06:59:05.000Z" title="Created 2023-03-10 14:59:05">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/10/Attention%20%E6%9C%BA%E5%88%B6%E6%8E%A8%E5%AF%BC/" title="Attention 机制推导"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Attention 机制推导"/></a><div class="content"><a class="title" href="/2023/03/10/Attention%20%E6%9C%BA%E5%88%B6%E6%8E%A8%E5%AF%BC/" title="Attention 机制推导">Attention 机制推导</a><time datetime="2023-03-10T06:10:51.000Z" title="Created 2023-03-10 14:10:51">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/30/Java%20Hash%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1/" title="Java Hash函数设计"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Hash函数设计"/></a><div class="content"><a class="title" href="/2022/12/30/Java%20Hash%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1/" title="Java Hash函数设计">Java Hash函数设计</a><time datetime="2022-12-30T03:10:39.000Z" title="Created 2022-12-30 11:10:39">2022-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/Phoenix%20%E5%8E%9F%E7%90%86/" title="Phoenix 原理"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Phoenix 原理"/></a><div class="content"><a class="title" href="/2022/12/29/Phoenix%20%E5%8E%9F%E7%90%86/" title="Phoenix 原理">Phoenix 原理</a><time datetime="2022-12-29T02:26:18.000Z" title="Created 2022-12-29 10:26:18">2022-12-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xinrihui</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>