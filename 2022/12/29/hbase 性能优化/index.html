<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HBase 性能优化 | 小灰灰在青青草原</title><meta name="author" content="Xinrihui"><meta name="copyright" content="Xinrihui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="hbase 性能优化&amp;nbsp;&amp;nbsp;1.内存 调优1.1 调大 JVM 的堆内存（1）修改$HBASE_HOME&#x2F;conf&#x2F;hbase-env.sh，export HBASE_HEAPSIZE&#x3D;8G这个参数会影响所有HBase实例，包括Master和Region。这样的话Master和RegionServer都会占用8GB。不过我建议大家用Master和RegionServer专有的">
<meta property="og:type" content="article">
<meta property="og:title" content="HBase 性能优化">
<meta property="og:url" content="https://xinrihui.github.io/2022/12/29/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="小灰灰在青青草原">
<meta property="og:description" content="hbase 性能优化&amp;nbsp;&amp;nbsp;1.内存 调优1.1 调大 JVM 的堆内存（1）修改$HBASE_HOME&#x2F;conf&#x2F;hbase-env.sh，export HBASE_HEAPSIZE&#x3D;8G这个参数会影响所有HBase实例，包括Master和Region。这样的话Master和RegionServer都会占用8GB。不过我建议大家用Master和RegionServer专有的">
<meta property="og:locale">
<meta property="article:published_time" content="2022-12-29T02:26:18.000Z">
<meta property="article:modified_time" content="2023-03-10T15:20:33.399Z">
<meta property="article:author" content="Xinrihui">
<meta property="article:tag" content="HBase">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xinrihui.github.io/2022/12/29/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HBase 性能优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-03-10 23:20:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="小灰灰在青青草原" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小灰灰在青青草原</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HBase 性能优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-29T02:26:18.000Z" title="Created 2022-12-29 10:26:18">2022-12-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-03-10T15:20:33.399Z" title="Updated 2023-03-10 23:20:33">2023-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97/">分布式数据库系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HBase 性能优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.6.1 (469462)"/><meta name="author" content="735407517@qq.com"/><meta name="created" content="2020-12-29 02:46:01 +0000"/><meta name="source" content="desktop.win"/><meta name="source-application" content="yinxiang.win32"/><meta name="source-url" content="https://www.cnblogs.com/smartloli/p/9425343.html"/><meta name="updated" content="2022-12-29 02:18:18 +0000"/><title>hbase 性能优化</title></head><body><div><div><div>&nbsp;&nbsp;</div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">1.内存 调优</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt; font-weight: bold;">1.1 调大 JVM 的堆内存</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;">（1）修改$HBASE_HOME/conf/hbase-env.sh，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">export HBASE_HEAPSIZE=8G</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个参数会影响所有HBase实例，包括Master和Region。这样的话</span><span style="font-size: 12pt; color: unset; font-family: unset;">Master和RegionServer都会占用8GB。不过我建议大家用Master和</span><span style="font-size: 12pt; color: unset; font-family: unset;">RegionServer专有的参数来分别设定他们的内存大小。</span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/45D2C9E6-6244-4C9A-B009-C8C2DD36ACF7.png" height="59" width="753"/></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;">现在有一台16GB的机器，上面有MapReduce服务、</span><span style="font-size: 12pt; color: unset; font-family: unset;">RegionServer和DataNode（这三位一般都是装在一起的），那么建议按</span><span style="font-size: 12pt; color: unset; font-family: unset;">照如下配置设置内存：</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;">2GB：留给系统进程。</span></div><div><span style="font-size: 12pt;">8GB：MapReduce服务。平均每1GB分配 6个Map slots + 2个</span><span style="font-size: 12pt; color: unset; font-family: unset;">Reduce slots。</span></div><div><span style="font-size: 12pt;">4GB：HBase的RegionServer服务。</span></div><div><span style="font-size: 12pt;">1GB：TaskTracker。</span></div><div><span style="font-size: 12pt;">1GB：DataNode。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果同时运行MapReduce的话，RegionServer将是除了MapReduce以</span><span style="font-size: 12pt; color: unset; font-family: unset;">外使用内存最大的服务。如果没有MapReduce的话，RegionServer可以</span><span style="font-size: 12pt; color: unset; font-family: unset;">调整到大概一半的服务器内存。</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">1.2 BlockCache&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">读请求先到Memstore中查数据，查不到就到BlockCache中查，再查不到就会到磁盘上读，并把读的结果放入BlockCache。由于BlockCache采用的是LRU策略，因此BlockCache达到上限 (heapsize&nbsp;&nbsp;*&nbsp;&nbsp;hfile.block.cache.size&nbsp;&nbsp;*&nbsp;&nbsp;0.85) 后，会启动淘汰机制，淘汰掉最老的一批数据。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一个Regionserver上有一个BlockCache和N个Memstore，它们的大小之和不能大于等于heapsize&nbsp;&nbsp;*&nbsp;&nbsp;0.8，否则HBase不能启动。对于注重读响应时间的系统，可以将&nbsp;&nbsp;BlockCache设大些，比如设置BlockCache=0.4，Memstore=0.39，以加大缓存的命中率。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以通过在hbase-site.xml配置以下属性来实现：</span></div><div><span style="font-size: 12pt;">* hfile.block.cache.size，默认0.4，用来提高读性能</span></div><div><span style="font-size: 12pt;">* hbase.regionserver.global.memstore.size，默认0.4，用来提高写性能</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了提高读性能，这里我们可以将BlockCache的占比设置大一些，Memstore 的占比设置小一些（总占比保持在0.8即可）。</span></div><div><span style="font-size: 12pt;">另外，BlockCache的策略选择也是很重要的，不同的策略对于读性能来说影响不大，但是对于GC的影响却比较明显，在设置 hbase.bucketcache.ioengine 属性为 offheap时，GC表现的很优秀。缓存结构如下图所示：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/7ACBF8B4-BD93-4063-B2A9-73E25BE19C8B.png" height="700" width="838"/></span></div><div><span style="font-size: 12pt;">JVM 的堆内存 和 堆外内存的 大小可以 在 hbase-env.sh 中配置。因为 栈内存很小 所以 JVM 不用配置 栈内存的大小。&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">设置BlockCache可以在 hbase-site.xml 文件中，配置如下属性：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">&lt;!-- 分配的内存大小尽可能的多些，前提是不能超过 (机器实际物理内存-JVM内存) --&gt;</span></div><div><span style="font-size: 12pt;"><property>&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<name>hbase.bucketcache.size</name>&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<value>16384</value></span></div><div><span style="font-size: 12pt;">&lt;/property&gt;</span></div><div><span style="font-size: 12pt;">&lt;property&gt;</span></div><div><span style="font-size: 12pt;">&lt;name&gt;hbase.bucketcache.ioengine&lt;/name&gt;</span></div><div><span style="font-size: 12pt;">&lt;value&gt;offheap&lt;/value&gt;</span></div><div><span style="font-size: 12pt;">&lt;/property&gt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; letter-spacing: normal; orphans: 2; text-align: left; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">设置块内存大小，可以参考入下表格：</span></span></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 352px;"/><col style="width: 282px;"/><col style="width: 130px;"/></colgroup><tbody style="margin: 0px; padding: 0px;"><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">标号</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">描述</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">计算公式或值</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">结果</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">A</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">物理内存选择：on-heap(JVM)+off-heap(Direct)</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">单台物理节点内存值，单位MB</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">262144</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">B</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">HBASE_HEAPSIZE('-Xmx)</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">单位MB</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">20480</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">C</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">-XX:MaxDirectMemorySize，off-heap允许的最大内存值</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">A-B</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">241664</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">Dp</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">hfile.block.cache.size 和hbase.regionserver.global.memstore.size总和不要超过0.8</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">读取比例占比*0.8</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">0.5*0.8=0.4</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">Dm</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">JVM Heap允许的最大BlockCache（MB）</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">B*Dp</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">20480*0.4=8192</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">Ep</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">hbase.regionserver.global.memstore.size设置的最大JVM值</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">0.8-Dp</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">0.8-0.4=0.4</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">F</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">用于其他用途的off-heap内存，例如DFSClient</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">推荐1024到2048</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">2048</span></div></td></tr><tr style="padding: 0px;"><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">G</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 352px; padding: 8px;"><div style="font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">BucketCache允许的off-heap内存</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 282px; padding: 8px;"><div style="background-color: rgb(255, 255, 255); font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">C-F</span></div></td><td style="border-collapse: collapse; border: 1px solid rgb(192, 192, 192); width: 130px; padding: 8px;"><div style="font-size: 14px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">241664-2048=239616</span></div></td></tr></tbody></table><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/smartloli/p/9425343.html" style="font-size: 12pt;">https://www.cnblogs.com/smartloli/p/9425343.html</a></span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">1.2.1&nbsp;&nbsp;</span><span style="font-size: 12pt; font-weight: bold;">LRUBlock Cache</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">首当其冲的肯定就是完全基于JVM heap的LRU方案了。在0.92版本&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">之前只有这种BlockCache的实现方案。LRU就是Least Recently Used，</span><span style="font-size: 12pt;">即近期最少使用算法的缩写。读出来的block会被放到BlockCache中待</span><span style="font-size: 12pt; color: unset; font-family: unset;">下次查询使用。当缓存满了的时候，会根据LRU的算法来淘汰block。</span><span style="font-size: 12pt; color: unset; font-family: unset;">LRUBlockCache 被分为三个区域，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">目前BlockCache的堆内内存方案就只有LRUBlockCache，而且你还</span><span style="font-size: 12pt; color: unset; font-family: unset;">关不掉它，只能调整它的大小。</span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">相关参数为：</span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/A61CCA7B-7C6F-41FB-B882-1D94ACFDE2E2.png" height="27" width="613"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">设置 hfile.block.cache.size 的时候要注意在HBase的内存使用上有一个规则那就是 Memstor+ BlockCache 的内存占用比例不能超过0.8（即80%），否则就要报错。因为必须要留20%作为机动空间。用配置项来说明：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/124E4ED6-34AB-4967-BAD8-87A13EFB89A7.png" height="28" width="638"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">值得一提的是，这两个配置项的默认值都是0.4，也就是说默认项</span><span style="font-size: 12pt; color: unset; font-family: unset;">的总和就已经达到了他们俩可以占用的内存比例上限了，所以基本没事</span><span style="font-size: 12pt; color: unset; font-family: unset;">就不用去加大这两个配置项，你调大哪一个，都必须相应地调小另外一</span><span style="font-size: 12pt; color: unset; font-family: unset;">个。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是LRUBlockCache有什么坏处呢？</span><span style="font-size: 12pt; color: unset; font-family: unset;">完全基于JVM Heap的缓存，势必带来一个后果：随着内存中对象越</span><span style="font-size: 12pt; color: unset; font-family: unset;">来越多，每隔一段时间都会引发一次Full GC。凡是做了几年Java的人</span><span style="font-size: 12pt; color: unset; font-family: unset;">听到Full GC都会浑身一颤。在Full GC的过程中，整个JVM完全处于停</span><span style="font-size: 12pt; color: unset; font-family: unset;">滞状态，有的时候长达几分钟</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">1.2.2&nbsp;&nbsp;</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Bucket Cache</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">JVM对</span><span style="font-size: 12pt; color: unset; font-family: unset;">堆（Heap）的管理很完善，会自动地回收对象，而不是像C语言一样要</span><span style="font-size: 12pt; color: unset; font-family: unset;">手动去回收，这就是大家从C语言转到Java的众多理由之一。这部分内</span><span style="font-size: 12pt;">存叫堆内内存（on-heap memory）。堆外内存（off-heap memory）是</span><span style="font-size: 12pt; color: unset; font-family: unset;">不属于JVM管理的内存范围，说白了，就是原始的内存区域了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">堆外内</span><span style="font-size: 12pt; color: unset; font-family: unset;">存的大小可以通过-XX:MaxDirectMe morySize=60MB这样来设置。可是</span><span style="font-size: 12pt; color: unset; font-family: unset;">用堆外内存肯定没有像用堆内内存那么好用啊，因为这就是一片原始的</span><span style="font-size: 12pt; color: unset; font-family: unset;">荒野，没有什么管理机制，那为什么要用它呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最大的好处就是：回收堆外内存的时候JVM几乎不会停顿，这样再</span><span style="font-size: 12pt; color: unset; font-family: unset;">也不用怕回收的时候业务系统卡住了。既然堆外内存回收的时候不会</span><span style="font-size: 12pt; color: unset; font-family: unset;">卡，为什么大家不都去用它呀？这是因为堆外 内存的缺点几乎比它带</span><span style="font-size: 12pt; color: unset; font-family: unset;">来的好处还大：</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">因为在堆外内存存储的数据都是很原始的数据，如果是一个对</span><span style="font-size: 12pt; color: unset; font-family: unset;">象，比如先序列化之后才能存储，所以不能存储太复杂的对象。</span></div></li><li><div><span style="font-size: 12pt;">堆外内存并不是在JVM的管理范围，所以当内存泄露的时候很不</span><span style="font-size: 12pt; color: unset; font-family: unset;">好排查问题。</span></div></li><li><div><span style="font-size: 12pt;">堆外内存由于用的是系统内存，当你用的太大的时候，物理内存</span><span style="font-size: 12pt; color: unset; font-family: unset;">有可能爆掉，或者直接开启了虚拟内存，也就是直接影响到了硬</span><span style="font-size: 12pt; color: unset; font-family: unset;">盘的使用。</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">BucketCache借鉴了SlabCache的创意，也用上了堆外内存。不过它</span><span style="font-size: 12pt; color: unset; font-family: unset;">是这么用的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">BucketCache一上来就分配了</span><span style="font-size: 12pt; color: unset; font-family: unset;">14种区域。注意：我这里说的是14种区域，并不是14块区域。这</span><span style="font-size: 12pt; color: unset; font-family: unset;">14种区域分别放的是大小为4KB、8KB、16KB、32KB、40KB、</span><span style="font-size: 12pt; color: unset; font-family: unset;">48KB、56KB、64KB、96KB、128KB、192KB、256KB、384KB、</span><span style="font-size: 12pt; color: unset; font-family: unset;">512KB的Block。而且这个种类列表还是可以手动通过设置&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">hbase.bucketcache.bucket.sizes 属性来定义（种类之间用逗号</span><span style="font-size: 12pt; color: unset; font-family: unset;">分隔，想配几个配几个，不一定是14个！），这14种类型可以分</span><span style="font-size: 12pt; color: unset; font-family: unset;">配出很多个Bucket</span></div></li><li><div><span style="font-size: 12pt;">BucketCache的存储不一定要使用堆外内存，是可以自由在3种存</span><span style="font-size: 12pt; color: unset; font-family: unset;">储介质直接选择：堆（heap）、堆外（offheap）、文件</span><span style="font-size: 12pt; color: unset; font-family: unset;">（file）。通过设置hbase.bucketcache.ioengine为heap、</span><span style="font-size: 12pt; color: unset; font-family: unset;">offfheap或者file来配置。</span></div></li><li><div><span style="font-size: 12pt;">每个Bucket的大小上限为最大尺寸的block * 4，比如可以容纳</span><span style="font-size: 12pt; color: unset; font-family: unset;">的最大的Block类型是512KB，那么每个Bucket的大小就是 512KB</span><span style="font-size: 12pt; color: unset; font-family: unset;">* 4 = 2048KB。</span></div></li><li><div><span style="font-size: 12pt;">系统一启动BucketCache就会把可用的存储空间按照每个Bucket</span><span style="font-size: 12pt; color: unset; font-family: unset;">的大小上限均分为多个Bucket。如果划分完的数量比你的种类还</span><span style="font-size: 12pt; color: unset; font-family: unset;">少，比如比14（默认的种类数量）少，就会直接报错，因为每一</span><span style="font-size: 12pt; color: unset; font-family: unset;">种类型的Bucket至少要有一个Bucket。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">BucketCache实现起来的样子就像如图8-12所示（每个区域的大小</span><span style="font-size: 12pt; color: unset; font-family: unset;">都是512 * 4）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/AC705B76-BB0E-4D65-AA43-1BB6E7811D8D.png" height="363" width="567"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">BucketCache还有一个特别的长处，那就是它自己来划分内存空</span><span style="font-size: 12pt; color: unset; font-family: unset;">间、自己来管理内存空间，Block放进去的时候是考虑到offset偏移量</span><span style="font-size: 12pt; color: unset; font-family: unset;">的（具体可以看源码的BucketAllocator），所以内存碎片少，发生GC&nbsp;&nbsp;</span><span style="font-size: 12pt;">的时间很短。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">大家不要忘记了还有SSD硬盘，最开始设计这种策</span><span style="font-size: 12pt; color: unset; font-family: unset;">略的初衷就是想把SSD作为一层比传统机械硬盘更快的缓存层来使用，</span><span style="font-size: 12pt; color: unset; font-family: unset;">所以你可以把file这种类型等同于SSD-file。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">BucketCache相关配置项如下：</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">hbase.bucketcache.ioengine：使用的存储介质，可选值为&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">heap、offheap、file。不设置的话，默认为offheap。</span></div></li><li><div><span style="font-size: 12pt;">hbase.bucketcache.combinedcache.enabled：是否打开 <span style="font-size: 12pt; font-weight: bold;">组合模</span></span><span style="font-size: 12pt; color: unset; font-family: unset;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">式</span>（CombinedBlockCache），默认为true，</span></div></li><li><div><span style="font-size: 12pt;">hbase.bucketcache.size：BucketCache所占的大小。</span><span style="font-size: 12pt; color: unset; font-family: unset;">如果设置为0.0~1.0，则代表了占堆内存的百分比。</span><span style="font-size: 12pt; color: unset; font-family: unset;">如果是大于1的值，则代表实际的BucketCache的大小，单位为MB。&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">默认值为0.0，即关闭BucketCache</span></div></li><li><div><span style="font-size: 12pt;">hbase.bucketcache.bucket.sizes：定义所有Block种类，默认</span><span style="font-size: 12pt; color: unset; font-family: unset;">为14种，种类之间用逗号分隔。单位为B，每一种类型必须是</span><span style="font-size: 12pt; color: unset; font-family: unset;">1024的整数倍，否则会报异常：java.io.IOException: Invalid&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">HFile block magic。默认值为：4、8、16、32、40、48、56、</span><span style="font-size: 12pt; color: unset; font-family: unset;">64、96、128、192、256、384、512。</span></div></li><li><div><span style="font-size: 12pt;">-XX:MaxDirectMemorySize：这个参数不是在hbase-site.xml中&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">配置的，而是JVM启动的参数。如果你不配置这个参数，JVM会按&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">需索取堆外内存；如果你配置了这个参数，你可以定义JVM可以&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">获得的堆外内存上限。显而易见的，这个参数值必须比&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">hbase.bucketcache.size大。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">组合模式</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在BucketCache的时代，也不是单纯地使用BucketCache，但是这回不是一二级缓存的结合；而是另一种模式，叫组合模式（CombinedBlockCahce）。具体地说就是把不同类型的Block分别放到LRUCache和BucketCache中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Index Block和Bloom Block会被放到LRUCache中。Data Block被直接放到BucketCache中，所以数据会去LRUCache查询一下，然后再去BucketCache中查询真正的数据。其实这种实现是一种更合理的二级缓存，数据从一级缓存到二级缓存最后到硬盘，数据是从小到大，存储介质也是由快到慢。考虑到成本和性能的组合，比较合理的介质是：LRUCache使用内存-&gt;BuckectCache使用SSD-&gt;HFile使用机械硬盘。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">关于LRUBlockCache和BucketCache单独使用谁比较强，曾经有人做</span><span style="font-size: 12pt; color: unset; font-family: unset;">过一个测试，并写了一篇报告出来，标题为Comparing BlockCache&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">Deploys，结论是：</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">因为BucketCache自己控制内存空间，碎片比较少，所以GC时间&nbsp;&nbsp;</span><span style="font-size: 12pt;">大部分都比LRUCache短。</span></div></li><li><div><span style="font-size: 12pt;">在缓存全部命中的情况下，LRUCache的吞吐量是BucketCache的</span><span style="font-size: 12pt; color: unset; font-family: unset;">两倍；在缓存基本命中的情况下，LRUCache的吞吐量跟&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">BucketCache基本相等。</span></div></li><li><div><span style="font-size: 12pt;">读写延迟，IO方面两者基本相</span><span style="font-size: 12pt; color: unset; font-family: unset;">等。</span></div></li><li><div><span style="font-size: 12pt;">缓存全部命中的情况下，LRUCache比使用fiile模式的&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">BucketCache CPU占用率低一倍，但是跟其他情况下差不多。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">从整体上说LRUCache的性能好于BucketCache，但由于Full GC的存</span><span style="font-size: 12pt; color: unset; font-family: unset;">在，在某些时刻JVM会停止响应，造成服务不可用。所以适当的搭配</span><span style="font-size: 12pt; color: unset; font-family: unset;">BucketCache可以缓解这个问题。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.3 GC 调优</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">随着内存的加大，有一个不容忽视的问题也出现了，那就是JVM的</span><span style="font-size: 12pt; color: unset; font-family: unset;">堆内存越大，Full GC的时间越久。Full GC有时候可以达到好几分钟。</span><span style="font-size: 12pt; color: unset; font-family: unset;">在Full GC的时候JVM会停止响应任何的请求，整个JVM的世界就像是停</span></div><div><span style="font-size: 12pt;">止了一样，所以这种暂停又被叫做Stop-The-World（STW）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">当ZooKeeper像往常一样通过心跳来检测RegionServer节点是否存</span><span style="font-size: 12pt; color: unset; font-family: unset;">活的时候，发现已经很久没有接收到来自RegionServer的回应，会直接</span><span style="font-size: 12pt; color: unset; font-family: unset;">把这个RegionServer标记为已经宕机。等到这台RegionServer终于结束</span><span style="font-size: 12pt; color: unset; font-family: unset;">了Full GC后，去查看ZooKeeper的时候会发现原来自己已经“被宕</span><span style="font-size: 12pt; color: unset; font-family: unset;">机”了，为了防止脑裂问题的发生，它会自己停止自己。这种场景称为</span><span style="font-size: 12pt; color: unset; font-family: unset;">RegionServer自杀，它还有另一个美丽的名字叫朱丽叶暂停，而且这问</span><span style="font-size: 12pt; color: unset; font-family: unset;">题还挺常见的，早期一直困扰着HBase开发人员。所以我们一定要设定</span><span style="font-size: 12pt; color: unset; font-family: unset;">好GC回收策略，避免长时间的Full GC发生，或者是尽量减小Full GC的</span><span style="font-size: 12pt; color: unset; font-family: unset;">时间。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">由于数据都是在RegionServer里面的，Master只是做一些管理操</span><span style="font-size: 12pt; color: unset; font-family: unset;">作，所以一般内存问题都出在RegionServer上。接下来主要用</span><span style="font-size: 12pt; color: unset; font-family: unset;">RegionServer来讲解参数配置</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JVM提供了4种GC回收</span></div><ul><li><div><span style="font-size: 12pt;">串行回收器（SerialGC）。</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">并行回收器（ParallelGC）</span>，主要针对年轻带进行优化（JDK 8&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">默认策略）。</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">并发回收器</span>（ConcMarkSweepGC，简称CMS），主要针对年老带进</span><span style="font-size: 12pt; color: unset; font-family: unset;">行优化。</span></div></li><li><div><span style="font-size: 12pt;">G1GC回收器，主要针对大内存（32GB以上才叫大内存）进行优</span><span style="font-size: 12pt; color: unset; font-family: unset;">化。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.3.1 ParallelGC和CMS的组合方案</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并行收回器的性能虽然没有串行回收器那么好，但是Full GC时间</span><span style="font-size: 12pt; color: unset; font-family: unset;">较短。对于RegionServer来说，Full GC是致命的，就算性能下降一些</span><span style="font-size: 12pt; color: unset; font-family: unset;">也没有关系，所以我们最好使用并行回收器。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并发回收器主要是减少老年代的暂停时间，可以保证应用不停止的</span><span style="font-size: 12pt; color: unset; font-family: unset;">情况下进行收集。但是它也有缺点，那就是每次都会留下一些“浮动垃</span><span style="font-size: 12pt; color: unset; font-family: unset;">圾”。这些浮动垃圾只能在下次垃圾回收的时候被回收，不过这些我们</span><span style="font-size: 12pt; color: unset; font-family: unset;">也可以忍受。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">基于以上描述比较符合HBase的配置是：</span></div><ul><li><div><span style="font-size: 12pt;">年轻带使用并行回收器ParallelGC。</span></div></li><li><div><span style="font-size: 12pt;">年老带使用并发回收器ConcMarkSweepGC。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">修改的方式还是修改$HBASE_HOME/conf/hbase-env.sh，</span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/8889B69B-175F-4056-AF5B-928A781EB61B.png" height="44" width="689"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.3.2 G1 GC方案</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你的JDK版本大于1.7.0_04（JDK7 update4），并且你的&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">RegionServer内存大于4GB&nbsp;&nbsp;</span><span style="font-size: 12pt;">可以考虑使用G1GC策略，这是JDK 7新</span><span style="font-size: 12pt; color: unset; font-family: unset;">加入的策略。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这种策略专门适用于堆内存很大的情况。引入G1GC策略的原因是，</span><span style="font-size: 12pt; color: unset; font-family: unset;">就算采用了CMS策略，我们还是不能避免Full GC。因为在以下两种情况</span><span style="font-size: 12pt; color: unset; font-family: unset;">下，CMS还是会触发Full GC：</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">在CMS工作的时候，有一些对象要从年轻代移动到老年代，但是</span><span style="font-size: 12pt; color: unset; font-family: unset;">此时老年代空间不足了，此时只能触发Full GC，然后引发&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">STW（Stop The World）暂停，JVM又开始不响应任何请求了。</span></div></li><li><div><span style="font-size: 12pt;">当被回收掉的内存空间太碎太细小，导致新加入老年代的对象放</span><span style="font-size: 12pt; color: unset; font-family: unset;">不进去，只好触发Full GC来整理空间，JVM还是会进入不响应任</span><span style="font-size: 12pt; color: unset; font-family: unset;">何请求的状态。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">G1GC策略通过把堆内存划分为多个Region，然后对各个Region单独</span><span style="font-size: 12pt; color: unset; font-family: unset;">进行GC，这样整体的Full GC可以被最大限度地避免（Full GC还是不可</span><span style="font-size: 12pt; color: unset; font-family: unset;">避免的，我们只是尽力延迟Full GC的到来时间），而且这种策略还可</span><span style="font-size: 12pt; color: unset; font-family: unset;">以通过手动指定MaxGCPauseMillis参数来控制一旦发生Full GC的时候</span><span style="font-size: 12pt; color: unset; font-family: unset;">的最大暂停时间，避免时间太长造成RegionServer自杀。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有一些简单的方式可以决</span><span style="font-size: 12pt; color: unset; font-family: unset;">定使用哪种策略：</span></div><ul><li><div><span style="font-size: 12pt;">RegionServer内存小于4GB，就不需要考虑G1GC策略</span><span style="font-size: 12pt; color: unset; font-family: unset;">了，直接用-XX:+UseParNewGC-XX:+UseConcMarkSweepGC。</span></div></li><li><div><span style="font-size: 12pt;">RegionServer内存大于32GB，建议使用G1GC策略</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">eg.</span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset;">问题：通过jstat命令发现 regionserver进程 full GC非常的频繁，甚至发现full GC的次数比young gc的次数还要多。full gc严重导致region server不稳定，经常运行几天后regionserver会死掉。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">原因：通过分析gc log以及实时观察，发现主要是读频发的时候，young区的S1，S2会很快到达100%，导致新的对象快速进入old区，此外，old区full gc不能有效快速回收内存，导致old去的内存一直维持在高位（总是高于设定的CMSInitiatingOccupancyFraction），所以导致old gc比young gc还多。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">尝试办法：由于young区在hbase读频繁的时候很快被填满，所以很自然的尝试便是增大young区的大小。但是大了以后产生了两个负面效果，一是young gc时间变长了，二是还是不能解决read的时候young区被快速填满的问题。这时意识到，单纯通过GC调参来解决full gc频繁问题的思路行不通了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">优化后的GC配置：</span></div><div><span style="font-size: 12pt;">export HBASE_MASTER_OPTS="$HBASE_MASTER_OPTS $HBASE_JMX_BASE -Xmx2000m -Xms2000m -Xmn750m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:-CMSIncrementalMode -XX:CMSInitiatingOccupancyFraction=70"</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">export HBASE_REGIONSERVER_OPTS="$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE -Xmx16000m -Xms16000m -Xmn7000m -XX:MaxDirectMemorySize=5g -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:-CMSIncrementalMode -XX:CMSInitiatingOccupancyFraction=75 -Xloggc:${HOME}/hdp_data/hbase/rs.log-`date +'%Y%m%d%H%M'` -verbose:gc -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCApplicationConcurrentTime -XX:SurvivorRatio=2 -XX:+PrintTenuringDistribution"</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用</span></span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/superhedantou/p/5424682.html" style="font-size: 12pt;">https://www.cnblogs.com/superhedantou/p/5424682.html</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2.数据的 压缩 与 编码</span></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2.1 压缩</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HBase在写入数据块到HDFS之前会首先对数据块进行压缩，再落盘，从而可以减少磁盘空间使用量。而在读数据的时候首先从HDFS中加载出block块之后进行解压缩，然后再缓存到BlockCache，最后返回给用户。写路径和读路径分别如下：</span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/C26F6AF6-0D1E-412D-AA8E-52645832AD04.png" height="166" width="737"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">（1） 资源使用情况：压缩最直接、最重要的作用即是减少数据硬盘容量，理论上snappy压缩率可以达到5:1，但是根据测试数据不同，压缩率可能并没有理论上理想；压缩/解压缩无疑需要大量计算，需要大量CPU资源；根据读路径来看，数据读取到缓存之前block块会先被解压，缓存到内存中的block是解压后的，因此和不压缩情况相比，内存前后基本没有任何影响。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">（2） 读写性能：因为数据写入是先将kv数据值写到缓存，最后再统一flush的硬盘，而压缩是在flush这个阶段执行的，因此会影响flush的操作，对写性能本身并不会有太大影响；而数据读取如果是从HDFS中读取的话，首先需要解压缩，因此理论上读性能会有所下降；如果数据是从缓存中读取，因为缓存中的block块已经是解压后的，因此性能不会有任何影响；一般情况下大多数读都是热点读，缓存读占大部分比例，压缩并不会对读有太大影响。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">目前 HBase 可以支持的压缩方式有 GZ（GZIP）、LZO、LZ4 以及 Snappy。它们之间的区别如下：</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt;">GZ：用于冷数据压缩，与 Snappy 和 LZO 相比，GZIP 的压缩率更高，但是更消耗 CPU，解压/压缩速度更慢。</span></div></li><li><div><span style="font-size: 12pt;">Snappy 和 LZO：用于热数据压缩，占用 CPU 少，解压/压缩速度比 GZ 快，但是压缩率不如 GZ 高。</span><span style="font-size: 12pt; color: unset; font-family: unset;">&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">Snappy 与 LZO 相比，Snappy 整体性能优于 LZO，Snappy 压缩率比 LZO 更低，但是解压/压缩速度更快。</span></div></li><li><div><span style="font-size: 12pt;">LZ4 与 LZO 相比，LZ4 的压缩率和 LZO 的压缩率相差不多，但是LZ4的解压/压缩速度更快。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">各种压缩各有不同的特点，我们需要根据业务需求（解压和压缩速率、压缩率等）选择不同的压缩格式。</span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/795B553B-D0FF-4173-B498-F6D2B432152A.png" height="139" width="744"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">多数情况下，选择Snappy或LZ0是比较好的选择，因为它们的压缩开销底，能节省空间。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">2.2 编码 （</span><span style="font-size: 12pt; font-weight: bold;">Data Block Encoding Types）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">HFile中，包含了好几个部分（</span><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://blog.cloudera.com/apache-hbase-i-o-hfile/" style="font-size: 12pt;">https://blog.cloudera.com/apache-hbase-i-o-hfile/</a></span><span style="font-size: 12pt;">）．我们这里只关心HFile里的Data Block．</span></div><div><span style="font-size: 12pt;">HFile在存储每一个Row时，不是把这一条Row的全部Family/Column整合成在一起，保存起来的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">RowKey | Family:Column1 -&gt; value | Family:Column2 -&gt; value</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它是把这条Row，根据Column拆分成好几个KeyValue，保存起来的，如下:</span></div><div><span style="font-size: 12pt;">RowKey/Family:Column1 -&gt; value</span></div><div><span style="font-size: 12pt;">RowKey/Family:Column2 -&gt; value</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们可以看到，RowKey需要重复保存很多次，而且Family:Column这个往往都是非常相似的，它也需要保存很多次．这对磁盘非常不友好．当Family:Column越多时，就需要占用越多不必要的磁盘空间．</span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">读数据时&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">我们的Block越小，能放到BlockCache中的数据就越多，命中率就越高，对Scan就越友好。</span></div><div><span style="font-size: 12pt;">Block Encoding&nbsp;&nbsp;</span><span style="font-size: 12pt;">通过减少HBase keyvalue中重复的部分来压缩数据。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">HBase还提供了数据编码功能。和压缩一样，数据在落盘之前首先会对KV数据进行编码；但又和压缩不同，数据块在缓存前并没有执行解码，因此即使后续命中缓存的查询也是编码的数据块，需要解码后才能获取到具体的KV数据。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/CDB1B182-21AE-40C3-8DFE-5FDE778E19AC.png" height="168" width="723"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">（1） 资源使用情况：和压缩一样，编码最直接、最重要的作用也是减少数据硬盘容量，但是压缩率一般没有数据压缩的压缩率高，理论上只有5:2；编码/解码一般也需要大量计算，需要大量CPU资源；根据读路径来看，数据读取到缓存之前block块并没有被解码，缓存到内存中的block是编码后的，因此和不编码情况相比，相同数据block快占用内存更少，即内存利用率更高。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">（2） 读写性能：和数据压缩相同，数据编码也是在数据flush到hdfs阶段执行的，因此并不会直接影响写入过程；前面讲到，数据块是以编码形式缓存到blockcache中的，因此同样大小的blockcache可以缓存更多的数据块，这有利于读性能。另一方面，用户从缓存中加载出来数据块之后并不能直接获取KV，而需要先解码，这却不利于读性能。可见，数据编码在内存充足的情况下会降低读性能，而在内存不足的情况下需要经过测试才能得出具体结论。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="http://www.aboutyun.com/data/attachment/forum/201607/03/101847fv2y77y2ybvqiyl3.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">prefix_tree压缩算法在不同的block size下性能都比较稳定，而另外两种压缩算法的查找性能会随着blocksize直线下降。对于我们默认的64K的block大小，性能相差40+倍。详见&nbsp;&nbsp;</span><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/zjushch-1843793" style="font-size: 12pt;">https://www.iteye.com/blog/zjushch-1843793</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">HBase中提供了五种Data Block Encoding Types，具体有:</span></div><div><span style="font-size: 12pt;">* NONE（不编码）</span></div><div><span style="font-size: 12pt;">* PREFIX</span></div><div><span style="font-size: 12pt;">* DIFF</span></div><div><span style="font-size: 12pt;">* FAST_DIFF</span></div><div><span style="font-size: 12pt;">* PREFIX_TREE（Trie tree）</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">PREFIX</span></div></li></ul><div><span style="font-size: 12pt;">一般来说，同一个Block中的Key(KeyValue中的Key，不仅包含RowKey，还包含Family:Column)，都很相似．它们往往只是最后的几个字符不同．</span></div><div><span style="font-size: 12pt;">例如，KeyA是RowKey:Family:Qualifier0，跟它相邻的下一个KeyB可能是&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">RowKey:Family:Qualifier1．</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在PREFIX中，相对于NONE，会额外添加一列，表示当前key(KeyB)和它前一个key(KeyA)，相同的前缀的长度(记为PrefixLength)．在上面的例子中，如果KeyA是这个Block中的第一个key，那它的PrefixLength就是0．而KeyB的PrefixLength是23．</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">很明显，如果相邻Key之间，完全没有共同点，那PREFIX显然毫无用处，还增加了额外的开销．</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当使用NONE这种Block Encoding时，如下图所示:</span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/742BFEB0-B769-46BC-A60A-1A93B80C2DDE.png" height="412" width="969"/></span></div><div><span style="font-size: 12pt;">如果采用PREFIX这种Block Encoding，那就是这样子了:</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/BA8CF5A3-9916-4F01-9FAD-9A83476F1E20.png" height="359" width="980"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">DIFF</span></div></li></ul><div><span style="font-size: 12pt;">DIFF是对PREFIX的一种改良．它把key看成很多个部分，对每部分进行压缩，提高效率．它添加了两个新的字段，timestamp和type．如果KeyB的ColumnFamily/key length/value length/type和KeyA相同，那么它就会在KeyB中被省略．</span><span style="font-size: 12pt; color: unset; font-family: unset;">另外，timestamp，存储的是相对于前一个Row的偏移量．</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">默认情况下，DIFF是不启用的．因为它会导致写数据，以及Scan数据更慢．但是，相对于PREFIX/NONE，它会在Block Cache中缓存更多数据．</span></div><div><span style="font-size: 12pt;">用DIFF压缩的block如下图所示:</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="/Resources/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.resources/70F84DAC-A29B-439E-B810-775DE69D3815.png" height="262" width="989"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">FAST_DIFF</span></div></li></ul><div><span style="font-size: 12pt;">FAST_DIFF跟DIFF非常相似，所不同的是，它额外增加了一个字段，表示RowB是否跟RowA完全一样，如果是的话，那数据就不需要重复保存了．</span></div><div><span style="font-size: 12pt;">如果在你的场景下，Key很长，或者有很多Column，那么推荐使用FAST_DIFF．</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">PREFIX_TREE</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">PREFIX_TREE是0.96中引入的．它大致跟PREFIX,DIFF,FAST_DIFF相同，但是它可以让随机读操作，比其它的几种更快．当然，代价是，MemStore写入到HFile时，需要进行更加复杂的Encoding操作，所以会更慢</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">它增加了一个叫做tree的字段．这个字段会保存指向这一Row中，全部Cell的索引．这对压缩更加友好．</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">详见</span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/HBASE-4676" style="font-size: 12pt;">https://issues.apache.org/jira/browse/HBASE-4676</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">修改</span> <span style="font-size: 12pt;">DATA_BLOCK_ENCODING 步骤</span><span style="font-size: 12pt;">：</span></div><div><span style="font-size: 12pt;">修改表的属性，此为压缩编码。</span></div><div><span style="font-size: 12pt;">alter 'test', {NAME =&gt; 'f', COMPRESSION =&gt; 'lz4', DATA_BLOCK_ENCODING =&gt;'DIFF'}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">压缩编码并不会立即生效，需要major_compact，此会耗时较长，注意在业务低峰期进行。</span></div><div><span style="font-size: 12pt;">major_compact 'test'</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2.3 实验&nbsp;&nbsp;</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">数据：6000w条记录，一个列族，每个列族10个列，单条记录总共1K大小；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">硬件：单RegionServer，3G BlockCache，CPU： 32&nbsp;&nbsp;&nbsp;&nbsp;Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">测试结果：</span></div><div><span style="font-size: 12pt;"><img src="http://www.aboutyun.com/data/attachment/forum/201607/03/101933n50f5rje75zlefje.png"/></span></div><div><span style="font-size: 12pt;"><img src="http://www.aboutyun.com/data/attachment/forum/201607/03/101942qx95xp4gaeeo2v3c.png"/></span></div><div><span style="font-size: 12pt;"><img src="http://www.aboutyun.com/data/attachment/forum/201607/03/101950h0b9c3ingxgggts1.png"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">设计原则：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 在任何场景下开启prefix_tree编码都是安全的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 在任何场景下都不要同时开启snappy压缩和prefix_tree编码</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. 通常情况下snappy压缩并不能比prefix_tree编码获得更好的优化结果，如果需要使用snappy需要针对业务数据进行实际测试</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">一个性能很高的 hbase 的 压力测试</span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/163yun/p/9661570.html" style="font-size: 12pt;">https://www.cnblogs.com/163yun/p/9661570.html</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用</span></font></div><div><br/></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43823423/article/details/101074648" style="font-size: 12pt;">https://blog.csdn.net/weixin_43823423/article/details/101074648</a></span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a62e49f749f3" style="font-size: 12pt;">https://www.jianshu.com/p/a62e49f749f3</a></span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hbase-community/p/8915498.html" style="font-size: 12pt;">https://www.cnblogs.com/hbase-community/p/8915498.html</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://blog.csdn.net/javastart/article/details/51820212" style="font-size: 12pt;">https://blog.csdn.net/javastart/article/details/51820212</a></span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://blog.csdn.net/javastart/category_6051883.html" style="font-size: 12pt;">https://blog.csdn.net/javastart/category_6051883.html</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">3.storefile 本地化 （</span><span style="font-size: 12pt; font-weight: bold;">locality）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因为DataNode和RegionServer通常会部署在相同的机器上，所以会产生Locality这样的概念。</span></div><div><span style="font-size: 12pt;">HBase的Locality是通过HDFS的Block复制实现的。在复制Block时，HBase是这样选择副本的位置的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一个副本写到本地节点上；</span></div><div><span style="font-size: 12pt;">第二个副本写到另一个机架的随机节点上；</span></div><div><span style="font-size: 12pt;">第三个副本写到相同机架的一个随机选择的其他节点上；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果还有更多的副本，这些副本将会写到集群上的随机节点上。</span><span style="font-size: 12pt; color: unset; font-family: unset;">在flush或compact后，HBase的Region实现了Locality。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当一个RegionServer处在failover的情况下（rebalance 或 重启）时，可能会分配到一些没有本地StoreFiles的Region（因为此时没有可用的本地副本）。然而，有新数据再写入这些Region的时候，或者是对表进行compact的时候，StoreFiles将会被重写，这些Region也会再次变成 RegionServer的“local”Region。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">HBASE 的表的 region 管理页面上 的指标“Locality”，即为 Region保存在本地的StoreFile的百分比。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">hbase compaction主要是合并memstore flush到磁盘上的HFile文件。主要分minor compaction和major compaction。minor compaction只会合并很少的hfile，这个花费的时间也不是很长。而major compaction会合并指定table的所有的HFile，所以花费的时间也比较长，但是能够显著提高hbase的读性能。</span></div><div><span style="font-size: 12pt;">考虑到白天hbase集群的负载并不是很高，所以很自然想到就是做手工major compaction。写一个简单的脚本就好了。其实就一行语句：echo "major_compact 'tablename'" | hbase shell，然后通过crontab定时启动就好了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">做了major compaction以后region server的block locality明显好转，hbase读的性能提升提升了50%以上</span>，晚上导表时间几乎缩短了一半。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用</span></span></div><div><span style="font-size: 12pt;"><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d3b8f5a2c3b" style="font-size: 12pt;">https://www.jianshu.com/p/4d3b8f5a2c3b</a></span></div><div><span style="font-size: 12pt;">《HBase&nbsp;&nbsp;不睡觉》</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">4.其他问题</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="color: rgb(255, 0, 0);"><span style="font-size: 12pt;">问题1：导入数据时出现 region server 挂掉的现象，检查&nbsp;&nbsp;</span><span style="font-size: 12pt;">region server 的日志 发现OOM</span></font></div><div><br/></div><div><span style="font-size: 12pt;">解决：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">调节 hbase-site.xml&nbsp;&nbsp; 中</span></div><div><span style="font-size: 12pt;">&lt;name&gt;hbase.regionserver.handler.count&lt;/name&gt;</span></div><div><span style="font-size: 12pt;">&lt;value&gt;180&lt;/value&gt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">180 太大了，这样在上传大文件或者scan大数据时，很容易OOM。</span><span style="font-size: 12pt; color: unset; font-family: unset;">默认10，可以适当调高，不能太大了，尤其需要上传或查询大表的场景</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></body></html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io">Xinrihui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io/2022/12/29/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">https://xinrihui.github.io/2022/12/29/hbase%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HBase/">HBase</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/29/Phoenix%20%E5%8E%9F%E7%90%86/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Phoenix 原理</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/29/hive%20%E8%BF%9E%E6%8E%A5/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">hive 连接</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/" title="HBase - 事务"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-24</div><div class="title">HBase - 事务</div></div></a></div><div><a href="/2022/12/29/Phoenix%20%E5%8E%9F%E7%90%86/" title="Phoenix 原理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-29</div><div class="title">Phoenix 原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xinrihui</div><div class="author-info__description">一个计算机民间爱好者的关于算法，分布式系统和机器学习的笔记，欢迎大佬拍砖交流～。笔者曾在微软亚洲研究院实习，参与国家重点研发计划，兴趣为分布式系统和机器学习。转载请注明引用（应该也没人看 ==），邮箱 xinrihui@outlook.com</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinrihui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/Evaluation/" title="Evaluation"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Evaluation"/></a><div class="content"><a class="title" href="/2023/03/16/Evaluation/" title="Evaluation">Evaluation</a><time datetime="2023-03-16T08:15:25.000Z" title="Created 2023-03-16 16:15:25">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/Learning%20to%20Rank/" title="Learning to Rank"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learning to Rank"/></a><div class="content"><a class="title" href="/2023/03/16/Learning%20to%20Rank/" title="Learning to Rank">Learning to Rank</a><time datetime="2023-03-16T08:15:25.000Z" title="Created 2023-03-16 16:15:25">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/" title="大数据系统的 lambda 框架"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据系统的 lambda 框架"/></a><div class="content"><a class="title" href="/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/" title="大数据系统的 lambda 框架">大数据系统的 lambda 框架</a><time datetime="2023-03-16T01:22:30.000Z" title="Created 2023-03-16 09:22:30">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" title="分布式系统综述"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式系统综述"/></a><div class="content"><a class="title" href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" title="分布式系统综述">分布式系统综述</a><time datetime="2023-03-10T06:59:05.000Z" title="Created 2023-03-10 14:59:05">2023-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/10/Attention%20%E6%9C%BA%E5%88%B6%E6%8E%A8%E5%AF%BC/" title="Attention 机制推导"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Attention 机制推导"/></a><div class="content"><a class="title" href="/2023/03/10/Attention%20%E6%9C%BA%E5%88%B6%E6%8E%A8%E5%AF%BC/" title="Attention 机制推导">Attention 机制推导</a><time datetime="2023-03-10T06:10:51.000Z" title="Created 2023-03-10 14:10:51">2023-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xinrihui</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>