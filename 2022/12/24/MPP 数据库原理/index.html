<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MPP 数据库原理 | 小灰灰在青青草原</title><meta name="author" content="Xinrihui"><meta name="copyright" content="Xinrihui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MPP 数据库原理part1. SMP &amp; MPP1.服务器的CPU 架构：（1）SMP (Symmetric Multi Processing) 对称多处理系统。所有的CPU共享全部资源，如总线，内存和I&#x2F;O系统等。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地">
<meta property="og:type" content="article">
<meta property="og:title" content="MPP 数据库原理">
<meta property="og:url" content="https://xinrihui.github.io/2022/12/24/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="小灰灰在青青草原">
<meta property="og:description" content="MPP 数据库原理part1. SMP &amp; MPP1.服务器的CPU 架构：（1）SMP (Symmetric Multi Processing) 对称多处理系统。所有的CPU共享全部资源，如总线，内存和I&#x2F;O系统等。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地">
<meta property="og:locale">
<meta property="article:published_time" content="2022-12-24T15:40:19.000Z">
<meta property="article:modified_time" content="2022-12-25T02:02:20.784Z">
<meta property="article:author" content="Xinrihui">
<meta property="article:tag" content="spark">
<meta property="article:tag" content="OLAP">
<meta property="article:tag" content="MPP">
<meta property="article:tag" content="MapReduce">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xinrihui.github.io/2022/12/24/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MPP 数据库原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-12-25 10:02:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="小灰灰在青青草原" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小灰灰在青青草原</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MPP 数据库原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-24T15:40:19.000Z" title="Created 2022-12-24 23:40:19">2022-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-25T02:02:20.784Z" title="Updated 2022-12-25 10:02:20">2022-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97/">分布式数据库系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MPP 数据库原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.6.1 (469462)"/><meta name="author" content="735407517@qq.com"/><meta name="created" content="2019-03-03 11:24:10 +0000"/><meta name="source" content="desktop.win"/><meta name="source-application" content="evernote.win32"/><meta name="source-url" content="https://www.zybuluo.com/hadoopMan/note/1005029"/><meta name="updated" content="2022-12-24 15:37:00 +0000"/><title>MPP 数据库原理</title></head><body><div><div><span style="font-weight: bold;"><font style="font-size: 16px;">part1. SMP &amp; MPP</font></span></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">1.服务器的CPU 架构：</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">（1）SMP (Symmetric Multi Processing) 对称多处理系统。</font></div><div><font style="font-size: 16px;">所有的CPU共享全部资源，如总线，内存和I/O系统等。多个CPU之间没有区别，平等地访问内存、外设、一个操作系统。操作系统管理着一个队列，每个处理器依次处理队列中的进程。如果两个处理器同时请求访问一个资源（例如同一段内存地址），由硬件、软件的锁机制去解决资源争用问题。每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而<span style="font-weight: bold;">最受限制的则是内存</span>。由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加。</font></div><div><font style="font-size: 16px;">（2）海量并行处理结构 (MPP ： Massive Parallel Processing)</font></div><div><font style="font-size: 16px;">由多个 SMP 节点  通过节点互联网络连接而成，<span style="font-weight: bold;">每个节点只访问自己的本地资源 ( 内存、存储等 )</span> ，是一种完全无共享 (Share Nothing) 结构，因而扩展能力最好。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">2.优点&amp;缺点</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">（1）MPP系统不共享资源，因此当需要处理的事务达到一定规模时，MPP的效率要比SMP好。由于MPP系统要在不同处理单元之间传送信息，在通讯时间少的时候，那MPP系统可以充分发挥资源的优势，达到高效率。也就是说：操作相互之间没有什么关系，处理单元之间需要进行的通信比较少，那采用MPP。典型的数据仓库环境具有大量复杂的数据处理和综合分析，要求系统具有很高的 I/O 处理能力，并且存储系统需要提供足够的 I/O 带宽与之匹配，因此适合MPP。</font></div><div><font style="font-size: 16px;">（2）OLTP 系统则以联机事务处理为主，每个交易所涉及的数据不多，要求系统具有很高的事务处理能力，能够在单位时间里处理尽量多的交易，因此适合SMP。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 16px;">引用</font></span></div><div><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html"><font style="font-size: 16px;">https://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html</font></a></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><span style="font-weight: bold;">part2. </span><span style="font-weight: bold;">以 impala 为例 理解 MPP 的 pipline 执行</span></font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">1. impala 是一个 MPP 的 查询引擎，它受到 google 的 dremel原理的启发而开发出来的，除了 dremel的全部功能之外，它提</font></div><div><font style="font-size: 16px;">供了 dremel不具备的 join 功能，可以说是 dremel的超集。</font></div><div><font style="font-size: 16px;"><img src="/Resources/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.resources/20415850-44E2-4408-A856-CF67E38E7A4E.png" height="311" width="402"/><br/></font></div><div><font style="font-size: 16px;">2.<span style="font-weight: bold;">impala与 hive 使用同一个元数据库</span>，可以与hive 实现互访，并兼容大部分HQL 语言。 其基本原理是将一个查询根据</font></div><div><font style="font-size: 16px;">数据所在位置分割成为子查询并在各个节点上运行，各个节点运行结果在汇总形成最终结果后返回给客户端。 impala的每</font></div><div><font style="font-size: 16px;">个节点都直接读取本地数据，并在本地执行子查询。 在执行子查询时，节点之间交换数据完成各自的查询。具体的查询树</font></div><div><font style="font-size: 16px;">（图 ２）分布化过程为：</font></div><div><font style="font-size: 16px;">（1）impala接收到 SQL查询首先生成SQL查询树，由查询树区分 在本地运行 或者 是在分布式系统上运行的查询</font></div><div><font style="font-size: 16px;">（2）把SQL查询 拆散后 分配到 到各个节点上，达到高速查询的目的</font></div><div><font style="font-size: 16px;">（3）各个节点直接从 HDFS 的本地文件读取数据，各个节点上分别进行 连接 和 聚合 操作，由各个节点把处理后的数据汇总发送到接受查询的节点上，由该节点进行汇总聚合及最后的排序截取工作。</font></div><div><font style="font-size: 16px;">（4）查询失败就全部重新执行，无法容错。</font></div><div><font style="font-size: 16px;"><img src="/Resources/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.resources/A88D3DDD-74C9-48DF-B0C3-E8139CC66D7B.png" height="292" width="356"/><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">3.impala 基本架构</font></div><div><font style="font-size: 16px;">impala 在每个节点上运行一个守护进程 impala daemon，每个节点都可以接受查询。 impala daemon 内部细分为impala</font></div><div><font style="font-size: 16px;">规划器（planner）、impala协调器（coordinator）、impala执行引擎（execengine）。 除此之外，impala 还需要运行状态存储器的守</font></div><div><font style="font-size: 16px;">护进程（statestore daemon），由状态存储器来保存和更新各个impala 的状态以供查询。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><img src="/Resources/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.resources/CD66E110-738B-44D0-87B7-FCA6D6CE389B.png" height="384" width="801"/><br/></font></div><div><font style="font-size: 16px;">（1）用户通过impala  shell、JDBC／ODBC 程序发送查询命令到一个 impala 节点上。各个节</font></div><div><font style="font-size: 16px;">点对等，都可以有 impala 守护进程，都可以接收查询请求。</font></div><div><font style="font-size: 16px;">（2）由 impala 规划器接收和分析查询命令，<span style="font-weight: bold;">它与 namenode上的 hive、HDFS元数据库</span>和状态储存器进行通信，<span style="font-weight: bold;">获得各部</span></font></div><div><font style="font-size: 16px;"><span style="font-weight: bold;">分数据的位置，并将查询命令分割成小的子查询</span>。 状态储存器保存了各个 impala 节点的状态。</font></div><div><font style="font-size: 16px;">（3）<span style="font-weight: bold;">impala 协调器将子查询分配到各个节点的 impala 执行引擎上</span>。</font></div><div><font style="font-size: 16px;">（4）各个 impala 执行引擎执行各自的查询，它们直接读取本地 HDFS或 hbase的数据，并与其他执行引擎进行通信</font></div><div><font style="font-size: 16px;">以完成各自的查询。</font></div><div><font style="font-size: 16px;">（5）各个 impala 执行引擎把部分结果返回给 impala 协调器。</font></div><div><font style="font-size: 16px;">（6）impala 协调器汇总部分结果组成最终结果，将最终结果返回给客户端。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 16px;">part3. 对比 MPP 和 批处理计算框架（ MapReduce 和 spark ）</font></span></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">1.每个executor有独立的cpu、内存和磁盘等资源，除非 遇到 shuffle 过程即数据通过网络进行交换，每个executor不能访问其他executor的资源。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">2.每个executor执行同样的数据处理逻辑，处理的数据则是这个executor所在的节点的本地存储的数据分片。下图中垂直的虚线表示同步点（发生 shuffle ）</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">3.MPP 中最大的问题是  “拖后腿的人（straggler） ” 。下图中 大部分时间里，一直都是一个executor7在孤独的执行，而由于shuffle 其他executor必须等待它执行完 。这就是MPP架构问题的根源所在，这种情况很容易发生，比如磁盘做了Raid，但是有磁盘突然坏了，raid的性能就会下降了，或者因为硬件或者OS的问题导致CPU性能下降。</font></div><div><font style="font-size: 16px;"><img src="/Resources/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.resources/916B631E-7E5B-4645-BBBE-3EE020027F44.png" height="705" width="1093"/><br/></font></div><div><font style="font-size: 16px;">4.并发是指可以有效的同时运行的查询数。MPP是完全“对称的”，即当查询开始执行时，每个节点都在并行的执行完全相同的任务。因此 <span style="font-weight: bold;">MPP支持的并发数和集群的节点数没有关系</span>。<span style="font-weight: bold;">MPP需要为高效数据处理速度放弃 并发</span>。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">5. 原本在两个同步点之间是单独的 stage 在执行，现在在MR中 则将stage切分成多个独立的“task”，在两个同步点之间，这些任务被随机的分配到空闲的executor上。而MPP的任务是和 这个 任务要处理的数据所在的节点绑定的（<span style="font-weight: bold;">计算和存储绑定</span>）。</font></div><div><font style="font-size: 16px;">MR 中，由于数据块 在多个节点上存在，这样计算框架可以在多个节点上启动任务处理本地数据，而不必在慢节点上吊死。</font></div><div><font style="font-size: 16px;">遇到性能差的 executor 只需要给他 较少的task即可。如果慢节点慢到实在不能忍，推测执行可以就会介入：执行慢的节点的任务会在其他节点启动，同时执行（谁先执行完就用谁的结果，而没有执行完的task会被kill掉）。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">6.MPP下，不需要把中间结果写入磁盘，因为每个executor处理一个task，所以数据可以直接“流入”下一执行阶段进行处理，这就是所谓的pipeline执行，性能非常可观。 但是如果在一个单独的executor中串行的处理不相关的task，就必须把中间结果写入本地磁盘，以便下一个stage能开始消费本 stage的数据。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">7.HAWQ 将 MPP和批处理系统进行了融合</font></div><div><font style="font-size: 16px;"><img src="/Resources/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.resources/BD325DAA-06F6-4FBA-B682-EA149CC2C93F.png" height="449" width="1120"/><br/></font></div><div><font style="font-size: 16px;">Greenplum中的segemnt是指常驻在节点上的PostgreSQL单独实例，当然这里的PostgreSql是经过修改的。这些单实例可以用来生成“executor”进程，每个查询在单节点对应一个executor。如果是小查询，可以由4个executor进程完成或者一个也可以。如果是大的查询，可能就需要100个甚至1000个executor了。不管查询是大是小，都是按照MPP的方式完成的，即一个进程只能处理本地数据，并且中间结果不写磁盘。但是虚拟segment则可以让executor在任何节点执行。</font></div><div><font style="font-size: 16px;">（1）可以动态增加和删除集群中的”straggler“节点，</font></div><div><font style="font-size: 16px;">（2）查询现在需要的executor数是动态的，这就可以得到更高的并发性</font></div><div><font style="font-size: 16px;">（3）数据pipeline。在两个stage之间，实时的把数据从一个executor传递到另外一个（独立的查询依然是MPP的流程，而不是批处理的流程），所以不需要把中间结果写磁盘</font></div><div><font style="font-size: 16px;">（4）MPP类似，我们仍然可以尽可能的在本地存储的数据上执行查询任务。每个executor尝试在存储自己需要处理数据百分比最高的节点上执行</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">8. MR 为了保证容错性，会对中间结果进行落盘并且要在落盘之后才能被下一个 task 读取，而序列化会带来高延迟。spark 发源之初是为了 改进 MR对迭代计算支持较差而设计的（并不是为了做 SQL查询，而是后来有人把它披上了SQL的外衣），但是仍然没有避免 落盘带来的时间开销。</font></div><div><font style="font-size: 16px;">而 MPP 计算模型 （eg. Greenplum <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(46, 46, 46);"><font face="Helvetica Neue">Impala</font></span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(46, 46, 46); font-family: &quot;Microsoft YaHei&quot;, 宋体, &quot;Myriad Pro&quot;, Lato, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;"> </span>）把整个查询 划分为 一颗 执行计划树，而不是一连串的MapReduce任务；在分发执行计划后，</font></div><div><font style="font-size: 16px;">MPP使用拉取数据的方式获取结果，把结果数据 从 执行计划树的最底层叶节点 向上 传递和汇集，这样 <span style="line-height: 1.45;">减少了落盘的开销。</span></font></div><div><font style="font-size: 16px;">但是它的缺点在于 容错性无法保证，需要从业务的层面来解决。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><img src="/Resources/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.resources/B27812C9-405C-4AE3-8A5D-B2FBDEDB2AF7.png" height="576" width="1338"/><br/></font></div><div><font style="font-size: 16px;">MPP下，不需要把中间结果写入磁盘，因为每个executor处理一个task，所以数据可以直接“流入”下一执行阶段进行处理，这就是所谓的pipeline执行，性能非常可观。<span style="font-weight: bold;">MR中，在一个单独的executor中串行的处理不相关的task，就必须把中间结果落盘，以便下一个执行步骤能开始消费本步骤的数据</span>。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 16px;">9.MR 和 MPP 的 设计思路</font></span></div><div><font style="font-size: 16px;"><br/></font></div><ul><li><div><font style="font-size: 16px;">hadoop ( MR + HDFS )</font></div></li></ul><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">    对于数据管理的理念是粗放型管理，以一个文件系统（HDFS）的模式，让用户根据文件夹的层级，把文件一股脑塞到一个分布式文件系统的大池子里面。而当用这些数据的时候，也是以批处理为主，所以每个机器上的文件基本都要从头到尾扫描一遍，所以也不存在太多的物理模型设计与逻辑模型设计。而数据库的本质在于数据管理，需要对外提供在线访问、增删改查等一系列操作。</font></div><div><font style="font-size: 16px;">     </font></div><div><font style="font-size: 16px;">    如果我们想在一大堆数据里面挑拣出符合某个条件的数据，数据库可以根据分区信息首先落到某个机器里，然后可以根据多维分区甚至落到某个文件上，之后再文件里面的索引数据页上使用树形结构查询，很快就可以定位到记录本身。能够做到这一切的前提是，数据库有一套很完善的数据管理和分布体系，因此查询、操作、更新、插入会非常直观高效。数据库能够做到高效的原因是把这些数据通过相对复杂的层级、分类、索引给管理起来，而Hadoop则通过完全放弃这些限制，获得了极大的自由度，但是丧失了对数据的管控能力。</font></div><div><font style="font-size: 16px;">     </font></div><div><font style="font-size: 16px;">    由于使用  这种粗放型的管理方式，只要简单地增加物理机就可以扩大hadoop的存储空间。而对于数据库来说，任何对于集群的改变都涉及到拓扑结构的变更，也可能会涉及到不同机器之间数据的迁移和 分区的记录进行重新散列 ，因此当集群中机器数量多的时候，依然维护复杂的数据管理模型会造成维护成本大幅度上升。</font></div><div><font style="font-size: 16px;">    </font></div><ul><li><div><font style="font-size: 16px;">MPP</font></div></li></ul><div><font style="font-size: 16px;">    </font></div><div><font style="font-size: 16px;">    mpp内存管理比较精细，他主要的想法是在每个机器上放个数据库。传统数据库的内存管理比较复杂，主要是内外存交互的东西，这样的架构决定了<span style="font-weight: bold;">mpp在小数据量的时候，latency 可以做的比较小，但是在大数据量的时候，Throughput做不上去</span>。MapReduce 的job是没有太多精细的内存管理的，他就是拼了命地scan，完了顶多就是个spill，这样的架构导致Throughput很大，但是latency很高。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><span style="font-size: 16px; color: black; font-family: 微软雅黑; font-weight: bold;">MPP 对比</span><span style="font-size: 16px; color: black; font-family: 微软雅黑; font-weight: bold;">MapReduce</span></div><ul><ul><li><div><span style="font-size: 16px; color: black; font-family: 微软雅黑;">低延迟：</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">shuffle</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">过程的中间结果无需落盘，直接流入下一阶段的执行器中执行，形成数据</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">pipeline</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">  </span></div></li><li><div><span style="font-size: 16px; color: black; font-family: 微软雅黑;">预聚合：</span><span style="font-size: 16px;" /><span style="font-size: 16px; color: black; font-family: 微软雅黑;">同一份</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">数据使用不同</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">的维度进行</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">组织，加快查询（</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">Apache</span><span style="font-size: 16px;" /><span style="font-size: 16px; color: black; font-family: 微软雅黑;">Kylin</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">：</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">Cube</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">）</span></div></li><li><div><span style="font-size: 16px; color: black; font-family: 微软雅黑;">容错性：查询失败后无法利用中间结果复原，</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">必须</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">重试整个查询</span></div></li><li><div><span style="font-size: 16px; color: black; font-family: 微软雅黑;">吞吐量</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">低</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">：复杂的数据管理模型（索引、</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">SQL</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">执行计划树）</span></div></li><li><div><span style="font-size: 16px; color: black; font-family: 微软雅黑;">可</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">扩展性低：小于</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">100</span><span style="font-size: 16px; color: black; font-family: 微软雅黑;">个节点</span></div></li></ul></ul><div><br/></div><div><span style="font-size: 16px;">MR 没有考虑数据之间的依赖关系,作业之间完全独立，中间结果需存入磁盘或通过网络进行节点传输, 无法形成数据pipeline。</span></div><div><br/></div><div><span style="font-size: 16px;">spark在窄依赖中,因为每一个父 分区只能被一个子 分区所使用。因此在窄依赖中每一个父  分区计算完成后可以直接将计算结果传给其对应的子 分区，无需等待其他  分区的计算完成，因此也就无需落盘。在宽依赖关系中,因为一个子 分区需要用到多个父 分区的计算结果，所以必须等待所有的 分区计算完成后才能进行子 RDD 的计算，这被称为 pipeline-breaker。为了容错性，先计算好的分区需要落盘，等待别的 task 来这里取走数据。</span></div><div><br/></div><div><span style="font-size: 16px;">Spark 会根据宽窄依赖关系划分出不同的阶段(stage)，然后再根据 RDD 自身保存的依赖关系形成一个有向无环图(DAG)进行调度。阶段之间为宽依赖。阶段内部的 RDD 全都为窄依赖关系：将具有窄依赖关系的 RDD 分区分配到一个任务中进行管道化操作，任务内部数据无需通过网络传输且任务之间互不干扰。特别是在阶段2中，mapreduce 要把 作业1 的结果落盘，而spark直接骚气的管道操作。</span></div><div><br/></div><div><span style="font-weight: bold; font-size: 16px;">总结 mapreduce ，spark 和 mpp，就是一个 中间计算结果是否落盘的权衡，落盘导致计算慢但是系统的容错好，即任务中间失败了我还可以从落盘的数据恢复任务。MR 是啥操作都落，spark是有shuffle才落，MPP是全在内存 “落盘是什么我不知道”</span></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><span style="font-weight: bold;">10.</span><span style="font-weight: bold;">MPP 和 MR 的结合</span></font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;">新型MPP 数据库 将逐步与Hadoop生态系统结合混搭使用，用MPP处理PB级别的、高质量的结构化数据，同时为应用提供丰富的SQL和事务支持能力; 用Hadoop实现半结构化、非结构化数据处理。这样可同时满足结构化、半结构化和非结构化数据的处理需求。</font></div><div><font style="font-size: 16px;">但是 impala对批量数据的处理如数据挖掘分析，不如HIVE稳定可靠。而impala天然是继承Hive的元数据，所以完全可以综合两者的优点，同一套数据，多个引擎。<span style="font-weight: bold;">Impala应对秒级的交互查询，Hive应对批量数据的分析</span>。即实现“<span style="font-weight: bold;">一套数据，多个引擎</span>”。</font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><font style="font-size: 16px;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 16px;">引用</font></span></div><div><font style="font-size: 16px;"><br/></font></div><div><a target="_blank" rel="noopener" href="http://blog.jobbole.com/43233/"><font style="font-size: 16px;">http://blog.jobbole.com/43233/</font></a></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22799482/answer/115844245"><font style="font-size: 16px;">https://www.zhihu.com/question/22799482/answer/115844245</font></a></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22037987"><font style="font-size: 16px;">https://www.zhihu.com/question/22037987</font></a></div><div><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27589901"><font style="font-size: 16px;">https://www.zhihu.com/question/27589901</font></a></div><div><a target="_blank" rel="noopener" href="https://www.zybuluo.com/hadoopMan/note/1005029"><font style="font-size: 16px;">https://www.zybuluo.com/hadoopMan/note/1005029</font></a></div><div><font style="font-size: 16px;"><br/></font></div></div><div><br/></div></body></html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io">Xinrihui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io/2022/12/24/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">https://xinrihui.github.io/2022/12/24/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spark/">spark</a><a class="post-meta__tags" href="/tags/OLAP/">OLAP</a><a class="post-meta__tags" href="/tags/MPP/">MPP</a><a class="post-meta__tags" href="/tags/MapReduce/">MapReduce</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">数据结构-查找</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">HBase - 事务</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/12/25/2.RDD%20%E7%AE%97%E5%AD%90/" title="Spark RDD 算子"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-25</div><div class="title">Spark RDD 算子</div></div></a></div><div><a href="/2022/12/25/1.shuffle%20%E7%A0%94%E7%A9%B6/" title="Spark shuffle 机制"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-25</div><div class="title">Spark shuffle 机制</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xinrihui</div><div class="author-info__description">一个计算机民间爱好者的关于算法，分布式系统和机器学习的笔记，欢迎大佬拍砖交流～。笔者曾在微软亚洲研究院实习，参与国家重点研发计划，兴趣为分布式系统和机器学习。转载请注明引用（应该也没人看 ==），邮箱 xinrihui@outlook.com</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinrihui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6/" title="文本相似度"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文本相似度"/></a><div class="content"><a class="title" href="/2023/03/16/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6/" title="文本相似度">文本相似度</a><time datetime="2023-03-16T08:46:48.000Z" title="Created 2023-03-16 16:46:48">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/Learning%20to%20Rank/" title="排序模型"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序模型"/></a><div class="content"><a class="title" href="/2023/03/16/Learning%20to%20Rank/" title="排序模型">排序模型</a><time datetime="2023-03-16T08:15:25.000Z" title="Created 2023-03-16 16:15:25">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/Evaluation/" title="评价指标"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="评价指标"/></a><div class="content"><a class="title" href="/2023/03/16/Evaluation/" title="评价指标">评价指标</a><time datetime="2023-03-16T08:15:25.000Z" title="Created 2023-03-16 16:15:25">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/" title="大数据系统的 lambda 框架"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据系统的 lambda 框架"/></a><div class="content"><a class="title" href="/2023/03/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%20lambda%20%E6%A1%86%E6%9E%B6/" title="大数据系统的 lambda 框架">大数据系统的 lambda 框架</a><time datetime="2023-03-16T01:22:30.000Z" title="Created 2023-03-16 09:22:30">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" title="分布式系统综述"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式系统综述"/></a><div class="content"><a class="title" href="/2023/03/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0/" title="分布式系统综述">分布式系统综述</a><time datetime="2023-03-10T06:59:05.000Z" title="Created 2023-03-10 14:59:05">2023-03-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xinrihui</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>