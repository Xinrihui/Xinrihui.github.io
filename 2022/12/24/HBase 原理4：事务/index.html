<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HBase - 事务 | 小灰灰在青青草原</title><meta name="author" content="Xinrihui"><meta name="copyright" content="Xinrihui"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HBase 原理4：事务HBase是BigTable的开源实现，事务模型也与BigTable一脉相承 – 仅支持行级别的事务。虽然Jeff Dean大神在接受采访时公开承认目前在技术领域最后悔的事情就是没有在BigTable中加入 跨行事务模型，以至于之后很多团队都在BigTable之上重复造各种各样的分布式事务轮子。之后Google又发布了一篇介绍分布式事务模型的的paper – Perc">
<meta property="og:type" content="article">
<meta property="og:title" content="HBase - 事务">
<meta property="og:url" content="https://xinrihui.github.io/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/index.html">
<meta property="og:site_name" content="小灰灰在青青草原">
<meta property="og:description" content="HBase 原理4：事务HBase是BigTable的开源实现，事务模型也与BigTable一脉相承 – 仅支持行级别的事务。虽然Jeff Dean大神在接受采访时公开承认目前在技术领域最后悔的事情就是没有在BigTable中加入 跨行事务模型，以至于之后很多团队都在BigTable之上重复造各种各样的分布式事务轮子。之后Google又发布了一篇介绍分布式事务模型的的paper – Perc">
<meta property="og:locale">
<meta property="article:published_time" content="2022-12-24T15:40:19.000Z">
<meta property="article:modified_time" content="2022-12-24T15:41:55.433Z">
<meta property="article:author" content="Xinrihui">
<meta property="article:tag" content="HBase">
<meta property="article:tag" content="事务">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xinrihui.github.io/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HBase - 事务',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-12-24 23:41:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="小灰灰在青青草原" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小灰灰在青青草原</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HBase - 事务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-12-24T15:40:19.000Z" title="Created 2022-12-24 23:40:19">2022-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-24T15:41:55.433Z" title="Updated 2022-12-24 23:41:55">2022-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97/">分布式数据库系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HBase - 事务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.6.1 (469462)"/><meta name="author" content="735407517@qq.com"/><meta name="created" content="2020-04-13 07:24:44 +0000"/><meta name="source" content="desktop.win"/><meta name="source-application" content="yinxiang.win32"/><meta name="source-url" content="http://hbasefly.com/2017/07/26/transaction-2/"/><meta name="updated" content="2022-02-17 13:42:51 +0000"/><title>HBase 原理4：事务</title></head><body><div><div><br/></div><div><span style="font-size: 12pt;">HBase是BigTable的开源实现，事务模型也与BigTable一脉相承 –</span> <span style="font-size: 12pt; font-weight: bold;">仅支持行级别的事务</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;">虽然Jeff Dean大神在接受采访时公开承认目前在技术领域最后悔的事情就是没有在BigTable中加入</span> <span style="font-size: 12pt; font-weight: bold;">跨行事务模型</span><span style="font-size: 12pt;">，以至于之后很多团队都在BigTable之上重复造各种各样的分布式事务轮子。</span></div><div><span style="font-size: 12pt;">之后Google又发布了一篇介绍分布式事务模型的的paper – Percolator，现在很多团队都参考该论文实现分布式事务，包括TiDB、Omid等</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">1.原子性</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HBase数据会首先写入WAL，再写入Memstore。写入Memstore异常很容易可以回滚，因此保证写入/更新原子性只需要保证 写入WAL的原子性即可。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HBase 0.98之前版本需要保证WAL写入的原子性并不容易，这由WAL的结构决定。</span></div><div><span style="font-size: 12pt;">假设一个行级事务更新R行中的3列（c1, c2, c3），来看看之前版本和当前版本的WAL结构：</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt;">之前版本WAL结构：</span></div></li></ul><div><span style="font-size: 12pt;">&lt;logseq1-for-edit1&gt;:&lt;KeyValue-for-edit-c1&gt;</span></div><div><span style="font-size: 12pt;">&lt;logseq2-for-edit2&gt;:&lt;KeyValue-for-edit-c2&gt;</span></div><div><span style="font-size: 12pt;">&lt;logseq3-for-edit3&gt;:&lt;KeyValue-for-edit-c3&gt;</span></div><div><span style="font-size: 12pt;">每个KV都会形成一个WAL单元，这样一行事务更新多少列就会产生多少个WAL单元。在将这些WAL单元append到日志文件的时候，一旦出现宕机或其他异常，就会出现部分写入成功的情况，原子性更新就无法保证。</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt;">当前版本WAL结构：</span></div></li></ul><div><span style="font-size: 12pt;">&lt;logseq#-for-entire-txn&gt;:&lt;WALEdit-for-entire-txn&gt;</span></div><div><span style="font-size: 12pt;">&lt;logseq#-for-entire-txn&gt;:&lt;-1, 3, &lt;Keyvalue-for-edit-c1&gt;, &lt;KeyValue-for-edit-c2&gt;, &lt;KeyValue-for-edit-c3&gt;&gt;</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">通过这种结构，每个事务 只会产生一个WAL单元。这样就可以保证WAL写入时候的原子性。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2.</span><span style="font-size: 12pt; font-weight: bold;">事务隔离性&nbsp;&nbsp;保证&nbsp;&nbsp;一致性</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">2.1 写写并发控制</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">现在假设有 两个 并发写入 请求同时进来，都对</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">同一行数据</span></span><span style="font-size: 12pt; font-weight: bold;">&nbsp;&nbsp;</span><span style="font-size: 12pt;">进行写入。下图所示RowKey为Greg，现在分别更新 列族info 下的 Company列 和 Role列：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">蓝色的写入请求：</span></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/F3C23DF7-D3E7-4928-9550-8D0556ED3255.png" height="90" width="680"/></span></div><div><span style="font-size: 12pt;">虽然是 一行数据&nbsp;&nbsp; 但是&nbsp;&nbsp;底层存储的&nbsp;&nbsp;为两个 K-V&nbsp;&nbsp;元组：</span></div><div><span style="font-size: 12pt;">( key= greg + info+company , value= Cloudera&nbsp;&nbsp; )</span></div><div><span style="font-size: 12pt;">( key= greg + info+role, value= Engineer )</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">绿色的写入请求：</span></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/D40D1C81-1E1A-41E5-AA81-48F2FCF22855.png" height="78" width="554"/></span></div><div><span style="font-size: 12pt;">( key= greg + info+company , value= Restaurant&nbsp;&nbsp; )</span></div><div><span style="font-size: 12pt;">( key= greg + info+role , value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;)</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果没有任何并发控制策略的话，写入数据（先写WAL，再写memstore）可能会出现不同 KV 写入”交叉”现象，如下图所示：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/BDCD880D-1000-451D-899A-1D13B2A63E33.png" height="313" width="752"/></span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">两个 并发请求&nbsp;&nbsp;都是操作同一行，这一行对应的 两个&nbsp;&nbsp;K-V&nbsp;&nbsp;元组（ 元组&nbsp;&nbsp;的值 即 value） 是&nbsp;&nbsp;交叉写入的：</span></span></div><div><span style="font-size: 12pt;">(key= greg + info+company , timestamp=1 , value= Cloudera&nbsp;&nbsp; )&nbsp;&nbsp;--&nbsp;&nbsp;蓝色的写入请求</span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">( key= greg + info+company , timestamp=2&nbsp;&nbsp; ,value= Restaurant&nbsp;&nbsp; )&nbsp;&nbsp;</span><span style="font-size: 12pt;">--&nbsp;&nbsp;绿色的写入请求</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">( key= greg + info+role , timestamp=3&nbsp;&nbsp; ,value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;绿色的写入请求 </span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">( key= greg + info+role ,&nbsp;&nbsp;timestamp=4 ,value= Engineer )&nbsp;&nbsp;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">&nbsp;&nbsp;</span><span style="font-size: 12pt;">--&nbsp;&nbsp;蓝色的写入请求</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">对于&nbsp;&nbsp;每一个&nbsp;&nbsp;</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">元组&nbsp;&nbsp;的值&nbsp;&nbsp;</span><span style="font-size: 12pt;">都会取&nbsp;&nbsp;时间戳（timestamp） 最大的（标红的）， 用户最终读取到&nbsp;&nbsp;一行 数据&nbsp;&nbsp;中的两个&nbsp;&nbsp;列（元组）会产生不一致，如下：</span></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/503BC97E-7B75-4524-8776-3F1FB3CB93D5.png" height="82" width="640"/></span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;对于 元组 可以 通过&nbsp;&nbsp; 时间戳版本&nbsp;&nbsp; 来 保证 事务，即&nbsp;&nbsp;某个 元组&nbsp;&nbsp;一定能保持一致性；</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是上述例子&nbsp;&nbsp;的中的&nbsp;&nbsp;不一致是出现在&nbsp;&nbsp;行上，</span></div><div><span style="font-size: 12pt;">即 一行数据的&nbsp;&nbsp; 各个列（元组）的版本&nbsp;&nbsp;出现了 混乱 ：company&nbsp;&nbsp;列取了&nbsp;&nbsp; 绿色写入请求，而 role 列 取了&nbsp;&nbsp;蓝色写入请求 ）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">问题：如何实现写写并发控制？</span></div><div><span style="font-size: 12pt;">只需要 在写入（或更新）之前先获取</span> <span style="font-size: 12pt; font-weight: bold;">行锁</span><span style="font-size: 12pt;">，如果获取不到，说明已经有其他线程拿了该锁，就需要不断重试等待或者自旋等待，直至其他线程释放该锁。拿到锁之后开始写入数据，写入完成之后释放行锁即可。这种行锁机制是实现写写并发控制最常用的手段，后面可以看到MySQL也是使用 行锁来实现写写并发的。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">问题：如何实现批量写入多行的写写并发？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HBase支持批量写入（或批量更新），即一个线程 同时</span> <span style="font-size: 12pt; font-weight: bold;">更新同一个Region&nbsp;&nbsp;中的多行记录</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;">那如何保证当前事务中的批量写入与其他事务中的批量写入的并发控制呢？与&nbsp;&nbsp;关系数据库 类似使用</span> <span style="font-size: 12pt; font-weight: bold;">两阶段锁协议：</span></div><div><span style="font-size: 12pt;">(1) 获取所有待写入（更新）行记录的行锁&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">(2) 开始执行写入（更新）操作</span></div><div><span style="font-size: 12pt;">(3) 写入完成之后再统一释放所有行记录的行锁</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">显然，两阶段锁协议&nbsp;&nbsp;可以避免出现死锁问题。（ 详见 《RDBMS》-> 2.数据库管理系统实现 -> 6.物理层的 并发控制）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是 ，</span> <span style="font-size: 12pt; font-weight: bold;">HBase&nbsp;&nbsp;的 两阶段&nbsp;&nbsp;锁协议&nbsp;&nbsp;仅仅保证了&nbsp;&nbsp;同一个 region&nbsp;&nbsp;内的隔离性，即 HBase&nbsp;&nbsp;仅支持&nbsp;&nbsp;同一个&nbsp;&nbsp;Region&nbsp;&nbsp;中的跨行事务</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt; font-weight: bold;">如果一个 事务&nbsp;&nbsp; 操作了 多个 region&nbsp;&nbsp;中的行 则&nbsp;&nbsp;还是会出现死锁</span><span style="font-size: 12pt;">。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">2.2 读写并发控制</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">读写之间是不是也需要一定的并发控制呢？如果不加并发控制，会出现什么现象呢？</span></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/AB4D9E36-BD93-4186-BFA4-0EA92F5EF3E8.png" height="451" width="1191"/></span></div><div><span style="font-size: 12pt;">上图分别是两个事务更新同一行数据，现在假设 第一个写事务（蓝色） 已经更新完成 ， 在第二个&nbsp;&nbsp;写事务（绿色）更新到一半的时候进来一个读请求，如果没有任何并发控制的话，读请求就会读到不一致的数据，Company列为Restaurant，Role列为Engineer</span></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/C0826838-55D2-4644-B2DA-F925866561A0.png" height="82" width="640"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">(key= greg + info+company , timestamp=1 , value= Cloudera&nbsp;&nbsp; )&nbsp;&nbsp;--&nbsp;&nbsp;蓝色的写入请求</span></div><div><span style="font-size: 12pt; color: rgb(255, 70, 53);">( key= greg + info+role ,&nbsp;&nbsp;timestamp=2 ,value= Engineer )</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">&nbsp;&nbsp;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">&nbsp;&nbsp;</span><span style="font-size: 12pt;">--&nbsp;&nbsp;蓝色的写入请求</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 70, 53);">( key= greg + info+company , timestamp=3&nbsp;&nbsp; ,value= Restaurant&nbsp;&nbsp; )&nbsp;&nbsp;</span><span style="font-size: 12pt;">--&nbsp;&nbsp;绿色的写入请求</span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">----------------&nbsp;&nbsp;读取 Greg&nbsp;&nbsp;行&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">( key= greg + info+role , timestamp=4&nbsp;&nbsp; ,value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;绿色的写入请求 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">M1：</span></div><div><span style="font-size: 12pt;">实现读写并发最简单的方法就是 仿照 写写并发控制 – 加锁（</span><span style="font-size: 12pt; font-weight: bold;">封锁法</span><span style="font-size: 12pt;">&nbsp;&nbsp;详见 《RDBMS》-> 2.数据库管理系统实现 ）。但几乎所有数据库都不会这么做，性能太差，对于读多写少的应用来说必然不可接受。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果&nbsp;&nbsp;一个事务要 写某行，肯定不能让&nbsp;&nbsp;其他事务&nbsp;&nbsp;同时来写，所以 必须加上&nbsp;&nbsp;写锁（排他锁 ，X锁），</span></div><div><span style="font-size: 12pt;">若不加 写锁，可能会出现&nbsp;&nbsp;</span> <span style="font-size: 12pt; font-weight: bold;">丢失更新</span><span style="font-size: 12pt;">&nbsp;&nbsp;（</span><span style="font-size: 12pt; font-weight: bold;">Lost update</span><span style="font-size: 12pt;">） （ 详见 《RDBMS》-> 2.数据库管理系统实现 -> 6.物理层的 并发控制 ），这就是&nbsp;&nbsp; 利用&nbsp;&nbsp;封锁法&nbsp;&nbsp;实现&nbsp;&nbsp; 写写并发控制。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果&nbsp;&nbsp;读写并发控制 也使用&nbsp;&nbsp;封锁法中的 X锁&nbsp;&nbsp;来 实现 ，即一个事务在写&nbsp;&nbsp;某行的时候 禁止别的事务来读，虽然&nbsp;&nbsp;可以达到&nbsp;&nbsp;最高的隔离级别——可串行化，但是 系统的并发度会下降；</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">另一方面，若一个事务在写&nbsp;&nbsp;某行的时候 ，随意让&nbsp;&nbsp;别的事务来读，那么会&nbsp;&nbsp;导致&nbsp;&nbsp;</span><span style="font-size: 12pt; font-weight: bold;">脏读（dirty read）</span><span style="font-size: 12pt;">&nbsp;&nbsp;、&nbsp;&nbsp;</span><span style="font-size: 12pt; font-weight: bold;">不可重复读（unrepeatable read）</span></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">（ 详见 《RDBMS》-&gt; 2.数据库管理系统实现 -&gt; 6.物理层的 并发控制 ）</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">其实，脏读&nbsp;&nbsp;和&nbsp;&nbsp;不可重复读&nbsp;&nbsp;也不是不可以&nbsp;&nbsp;容忍，这取决于&nbsp;&nbsp;应用要求的&nbsp;&nbsp;事务的隔离级别，（详见&nbsp;&nbsp; 《分布式&nbsp;&nbsp;存储和数据库》->&nbsp;&nbsp;分布式事务处理 ）</span></div><div><span style="font-size: 12pt;">若 隔离&nbsp;&nbsp;级别为&nbsp;&nbsp; 读未提交（Read Uncommitted），则&nbsp;&nbsp;可能出现&nbsp;&nbsp; 脏读；</span></div><div><span style="font-size: 12pt;">若&nbsp;&nbsp;隔离&nbsp;&nbsp;级别为&nbsp;&nbsp;读已提交（Read Committed），则不会出现脏读，但是&nbsp;&nbsp;会出现 不可重复读；</span></div><div><span style="font-size: 12pt;">若&nbsp;&nbsp;隔离&nbsp;&nbsp;级别为&nbsp;&nbsp;&nbsp;&nbsp;可重复读 （Repeatable Read&nbsp;&nbsp;），则不会&nbsp;&nbsp;出现&nbsp;&nbsp;脏读、不可重复读&nbsp;&nbsp;但是&nbsp;&nbsp;会出现&nbsp;&nbsp;幻读；</span></div><div><span style="font-size: 12pt;">若&nbsp;&nbsp;隔离&nbsp;&nbsp;级别为&nbsp;&nbsp;可串性化 （Serializable），则&nbsp;&nbsp;不会&nbsp;&nbsp;出现&nbsp;&nbsp;脏读、不可重复读 、&nbsp;&nbsp;幻读；</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">数据库&nbsp;&nbsp;一般不会选择&nbsp;&nbsp;可串行化，MySql默认的隔离级别为 Repeatable Read ，Oracle默认的隔离级别为 Read Committed</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因此，读写的并发&nbsp;&nbsp;控制&nbsp;&nbsp;可以采用&nbsp;&nbsp;下面的 MVCC&nbsp;&nbsp;方法&nbsp;&nbsp;</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">M2：</span><span style="font-size: 12pt; font-weight: bold;">MVCC</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HBase中 MVCC 机制实现主要分为两步：</span></div><ul><li><div><span style="font-size: 12pt;">在事务开始时，为每一个写（更新）事务 分配一个</span> <span style="font-size: 12pt; color: rgb(255, 0, 0);">Region级别</span> <span style="font-size: 12pt;">自增 的序列号</span></div></li><li><div><span style="font-size: 12pt;">为每一个读请求分配一个 已完成（已提交）的最大写事务序列号</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/5C08BC98-3C49-4C6E-818A-815C9094CAFF.png" height="571" width="1484"/></span></div><div><span style="font-size: 12pt;">上图中两个 写事务分别分配了 序列号1（wn=1）和 序列号2（wn=2），读请求进来的时候 事务1 已经完成（已经提交），事务2 还未完成，因此分配事务1 对应的序列号1给读请求。此时 序列号1对 本次读可见，序列号2 对本次读不可见，读到的数据是：</span></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/F3C23DF7-D3E7-4928-9550-8D0556ED3255.png" height="90" width="680"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">(key= greg + info+company , timestamp=1 , value= Cloudera , wn=1&nbsp;&nbsp; )</span><span style="font-size: 12pt; color: rgb(255, 70, 53);">&nbsp;&nbsp;</span><span style="font-size: 12pt;">--&nbsp;&nbsp;蓝色的写入请求</span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">( key= greg + info+role ,&nbsp;&nbsp;timestamp=1.5 ,value= Engineer ,&nbsp;&nbsp; wn=1 )&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-size: 12pt;">--&nbsp;&nbsp;蓝色的写入请求</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">wn&nbsp;&nbsp;list（commit list） : [ 1,&nbsp;&nbsp; ]</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">( key= greg + info+company , timestamp=2&nbsp;&nbsp; ,value= Restaurant , wn=2&nbsp;&nbsp; )&nbsp;&nbsp;--&nbsp;&nbsp;绿色的写入请求</span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">----------------&nbsp;&nbsp;读取 Greg&nbsp;&nbsp;行&nbsp;&nbsp; ( row=</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">greg ,&nbsp;&nbsp;</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">wn=max(&nbsp;&nbsp;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">wn_list&nbsp;&nbsp;</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">)=1</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">&nbsp;&nbsp; )</span></div><div><span style="font-size: 12pt;">( key= greg + info+role , timestamp=3&nbsp;&nbsp; ,value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;, wn=2&nbsp;&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp; --&nbsp;&nbsp;绿色的写入请求 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">wn&nbsp;&nbsp;list（commit list） : [ 1, 2 ]</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">由此可见，</span><span style="font-size: 12pt; font-weight: bold;">MVCC&nbsp;&nbsp;的隔离级别&nbsp;&nbsp;至少为：</span> <span style="font-size: 12pt; font-weight: bold;">读已提交</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">具体实现中，</span><span style="font-size: 12pt; font-weight: bold;">所有的写事务都会生成一个 Region级别 的自增序列</span><span style="font-size: 12pt;">，并添加到队列（每一个 region&nbsp;&nbsp;有一个）中，如下图最左侧队列，其中最底端为已经提交的事务，队列中的事务为未提交事务。现假设当前事务编号为15，并且写入完成（中间队列红色框框），但之前的写入事务还未完成（序列号为12、13、14的事务还未完成），此时当前事务必须等待，而且对读并不可见，直至之前所有事务完成之后才会对读可见（ 即读请求才能读取到该事务写入的数据 ）。如最右侧图，15号事务之前的所有事务都成功完成，此时Read Point就会移动到15号事务处，表示15号事务之前的所有改动都可见。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="/Resources/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1.resources/0B277B7C-EE1B-43DD-ACC4-91705871EF00.png" height="412" width="1067"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以，MVCC的精髓是&nbsp;&nbsp;</span> <span style="font-size: 12pt;">写入的时候分配 递增版本号（Sequence Id）（该版本信息取的是&nbsp;&nbsp; 事务开始时的时间戳），读取的时候分配&nbsp;&nbsp; 一个&nbsp;&nbsp;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">连续已完成最大</span> <span style="font-size: 12pt;">的版本 用于读取 可见，比之大的版本不可见</span><span style="font-size: 12pt;">。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">由此可见 ， 采用 MVCC 隔离级别&nbsp;&nbsp;至少可以达到：</span><span style="font-size: 12pt; font-weight: bold;">可重复读</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;">例如， A事务 读取的时候&nbsp;&nbsp;被分配了&nbsp;&nbsp;版本 wn=3，在A事务的&nbsp;&nbsp;生命期内&nbsp;&nbsp;无论它 读 多少次，一定只能 拿到&nbsp;&nbsp; 版本 wn=3 的数据；即使在&nbsp;&nbsp; A事务的&nbsp;&nbsp;生命期内，&nbsp;&nbsp; B事务&nbsp;&nbsp;更新了数据&nbsp;&nbsp;并提交成功，数据的最大版本变为 wn=4。</span><span style="font-size: 12pt; color: unset; font-family: unset;">因此，不会出现&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">不可重复读</span><span style="font-size: 12pt; color: unset; font-family: unset;">&nbsp;&nbsp;的现象。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HBase一个标准写事务的流程如下：</span></div><ul><li><div><span style="font-size: 12pt; color: unset; font-family: unset;">锁行，拒绝对相同行的并发写</span></div></li><li><div><span style="font-size: 12pt;">获取当前的写入号</span></div></li><li><div><span style="font-size: 12pt;">将修改写入“写前日志”WAL(Write Ahead Log)</span></div></li><li><div><span style="font-size: 12pt;">将修改写入Memstore，同时用获取到的写入号标记KeyValue对</span></div></li><li><div><span style="font-size: 12pt;">提交事务，即尝试将读取点滚到获取到的写入号(这样变更就可以对所有新的Scan可见)</span></div></li><li><div><span style="font-size: 12pt;">打开行锁</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">HBase</span><span style="font-size: 12pt;">一个标准读事务的流程如下：</span></div><ul><li><div><span style="font-size: 12pt;">打开Scanner</span></div></li><li><div><span style="font-size: 12pt;">获取当前读取点</span></div></li><li><div><span style="font-size: 12pt;">筛选出所有memstore时间戳大于读取点的KeyValue对</span></div></li><li><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关闭Scanner</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">问题：为什么&nbsp;&nbsp;读取的时候&nbsp;&nbsp;必须&nbsp;&nbsp;分配一个&nbsp;&nbsp;连续已完成最大 的版本（wn）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">1.保证了&nbsp;&nbsp;一个 Region&nbsp;&nbsp;内的&nbsp;&nbsp;单行事务：</span></div><div><br/></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">eg1.</span></span></div><div><span style="font-size: 12pt;">在同一个&nbsp;&nbsp;Region&nbsp;&nbsp;中：</span></div><ul><li><div><span style="font-size: 12pt;">t= 5 发起 写事务&nbsp;&nbsp;插入 TID=5 （</span><span style="font-size: 12pt; font-weight: bold;">TID&nbsp;&nbsp;取 事务开始时的时间戳</span><span style="font-size: 12pt;">） ：</span></div></li></ul><div><span style="font-size: 12pt;">( key= abby+ info+company , timestamp=5&nbsp;&nbsp; ,value= Restaurant , wn=5&nbsp;&nbsp; )</span></div><div><span style="font-size: 12pt;">( key=abby+ info+role , timestamp=</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">5.5</span><span style="font-size: 12pt;">&nbsp;&nbsp; ,value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;, wn=5 )&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">t= 7&nbsp;&nbsp;发起&nbsp;&nbsp;写事务&nbsp;&nbsp;插入&nbsp;&nbsp; TID=7：</span></div></li></ul><div><span style="font-size: 12pt;">( key= keven + info+company , timestamp=7&nbsp;&nbsp; ,value= Restaurant , wn=7&nbsp;&nbsp; )</span></div><div><span style="font-size: 12pt;">( key= keven+ info+role , timestamp=</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">11</span><span style="font-size: 12pt;">&nbsp;&nbsp; ,value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;, wn=7 )&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div><br/></div><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">t= 8&nbsp;&nbsp;</span><span style="font-size: 12pt;">发起 写事务</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">&nbsp;&nbsp;插入 TID=8：</span></div></li></ul><div><span style="font-size: 12pt;">( key= greg + info+company , timestamp=8&nbsp;&nbsp; ,value= Restaurant , wn=8&nbsp;&nbsp; )</span></div><div><span style="font-size: 12pt;">( key= greg + info+role , &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp= </span><span style="font-size: 12pt; color: rgb(255, 0, 0);">9</span><span style="font-size: 12pt;">&nbsp;&nbsp; , value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wn=8 )&nbsp;&nbsp; </span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">t=10&nbsp;&nbsp; 发起&nbsp;&nbsp;读事务 Read1 ，读取整个 region（分区） ，</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">此时， 已完成的&nbsp;&nbsp;最大版本号为 8 即</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">TID=8 已经提交</span><span style="font-size: 12pt;">，但是，</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">TID=7 还未提交，所以</span><span style="font-size: 12pt;">&nbsp;&nbsp;连续已完成的&nbsp;&nbsp;最大的版本号为 5&nbsp;&nbsp; ；</span></div><div><span style="font-size: 12pt;">因此 读事务Read1 能看&nbsp;&nbsp;版本&nbsp;&nbsp;小于等于 wn=5 的&nbsp;&nbsp;分区的数据，即&nbsp;&nbsp; keven&nbsp;&nbsp;和&nbsp;&nbsp;greg&nbsp;&nbsp;行 都看不到，即使&nbsp;&nbsp;Read1&nbsp;&nbsp; 在 t=12&nbsp;&nbsp;又读了一次数据。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">----------------------------------------------------------------------</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">假设&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">读取的时候分配 一个&nbsp;&nbsp; 已完成&nbsp;&nbsp; 最大的版本 用于读取 可见</span><span style="font-size: 12pt; color: unset; font-family: unset;">，而不要求&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">连续已完成&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset;">&nbsp;&nbsp;，则&nbsp;&nbsp;可能出现&nbsp;&nbsp;</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">幻读</span><span style="font-size: 12pt; color: unset; font-family: unset;">：</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt;">t=10&nbsp;&nbsp; 发起&nbsp;&nbsp;读事务 Read1 ，读取整个 region，</span></div></li></ul><div><span style="font-size: 12pt;">此时， 已完成的&nbsp;&nbsp;最大版本号为 8 即</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">TID=8 已经提交</span><span style="font-size: 12pt;">，</span></div><div><span style="font-size: 12pt;">读事务Read1 能看&nbsp;&nbsp;版本&nbsp;&nbsp;小于等于 wn=8 的&nbsp;&nbsp;分区的数据，但是不能看未提交的，因此：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当 t=10&nbsp;&nbsp; Read1&nbsp;&nbsp; 能看到&nbsp;&nbsp;abby&nbsp;&nbsp;greg&nbsp;&nbsp;行，看不到&nbsp;&nbsp;keven&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">当 t=12&nbsp;&nbsp;&nbsp;&nbsp;TID=7 已经提交，Read1&nbsp;&nbsp; 能看到&nbsp;&nbsp;&nbsp;&nbsp;abby&nbsp;&nbsp;greg&nbsp;&nbsp;keven&nbsp;&nbsp;行，此时出现了&nbsp;&nbsp;在一个事务中 ，看到了&nbsp;&nbsp;前一次读取 看不到的行：keven ，即</span> <span style="font-size: 12pt; font-weight: bold;">幻读</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">----------------------------------------------------------------------</span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">t=12&nbsp;&nbsp;发起&nbsp;&nbsp;读事务 Read2 ，读取整个 region，</span></div></li></ul><div><span style="font-size: 12pt;">此时，连续已完成的&nbsp;&nbsp;最大的版本号为 8 ，因此 读事务Read2&nbsp;&nbsp;能看&nbsp;&nbsp;版本&nbsp;&nbsp;小于等于 wn=8 的&nbsp;&nbsp;分区的数据，abby&nbsp;&nbsp;greg&nbsp;&nbsp;keven&nbsp;&nbsp;行&nbsp;&nbsp;均可见</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">2.事务写入的时候分配&nbsp;&nbsp;的 递增版本号 取的是&nbsp;&nbsp;事务提交后的时间戳，则 “读取的时候分配一个已完成最大的版本用于读取可见”&nbsp;&nbsp;也可以实现 跨行的事务</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">eg1.</span></span></div><div><span style="font-size: 12pt;">在同一个&nbsp;&nbsp;Region&nbsp;&nbsp;中：</span></div><ul><li><div><span style="font-size: 12pt;">t= 5 发起 写事务&nbsp;&nbsp;&nbsp;&nbsp;：</span></div></li></ul><div><span style="font-size: 12pt;">( key=</span> <span style="font-size: 12pt; font-weight: bold;">abby</span><span style="font-size: 12pt;">+ info+company , timestamp=5&nbsp;&nbsp; ,value= Restaurant , wn=5.5)</span></div><div><span style="font-size: 12pt;">( key=</span><span style="font-size: 12pt; font-weight: bold;">abby</span><span style="font-size: 12pt;">+ info+role , timestamp=5.5&nbsp;&nbsp; ,value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;, wn=5.5)&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">插入 TID=5.5 （</span><span style="font-size: 12pt; font-weight: bold;">TID&nbsp;&nbsp;取 事务&nbsp;&nbsp;提交的时间戳</span><span style="font-size: 12pt;">）</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt;">t= 7&nbsp;&nbsp;发起&nbsp;&nbsp;写事务 ：</span></div></li></ul><div><span style="font-size: 12pt;">( key=</span> <span style="font-size: 12pt; font-weight: bold;">keven</span> <span style="font-size: 12pt;">+ info+company , timestamp=7&nbsp;&nbsp; ,value= Restaurant , wn=11)</span></div><div><span style="font-size: 12pt;">( key=</span> <span style="font-size: 12pt; font-weight: bold;">keven</span><span style="font-size: 12pt;">+ info+role , timestamp=11&nbsp;&nbsp; ,value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;, wn=11)&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div><span style="font-size: 12pt;">插入&nbsp;&nbsp; TID=11</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">t= 8&nbsp;&nbsp;</span><span style="font-size: 12pt;">发起 写事务</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">&nbsp;&nbsp;：</span></div></li></ul><div><span style="font-size: 12pt;">( key=</span> <span style="font-size: 12pt; font-weight: bold;">greg</span> <span style="font-size: 12pt;">+ info+company , timestamp=8&nbsp;&nbsp; ,value= Restaurant , wn=9)</span></div><div><span style="font-size: 12pt;">( key=</span> <span style="font-size: 12pt; font-weight: bold;">greg</span> <span style="font-size: 12pt;">+ info+role , &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp=9&nbsp;&nbsp; , value=&nbsp;&nbsp;Waiter&nbsp;&nbsp;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wn=9)&nbsp;&nbsp; </span></div><div><span style="font-size: 12pt;">插入&nbsp;&nbsp; TID=9</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt;">t=10&nbsp;&nbsp; 发起&nbsp;&nbsp;读事务 Read1 ，读取整个 region（分区） ，</span></div></li></ul><div><span style="font-size: 12pt;">此时， 已完成（已提交）的&nbsp;&nbsp;最大版本号为 9 即</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">TID=9 已经提交</span><span style="font-size: 12pt;">，</span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">因此 读事务Read1 能看&nbsp;&nbsp;版本&nbsp;&nbsp;小于等于 wn=9 的&nbsp;&nbsp;分区的数据，即&nbsp;&nbsp;能看到&nbsp;&nbsp;abby&nbsp;&nbsp;&nbsp;&nbsp;greg&nbsp;&nbsp;行，而&nbsp;&nbsp; keven 行 看不到，即使&nbsp;&nbsp;Read1 ， 在 t=12&nbsp;&nbsp;Read1又读了一次数据，结果仍然如此。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里需要注意版本必须递增，而且&nbsp;&nbsp;</span><span style="font-size: 12pt; font-weight: bold;">唯一</span><span style="font-size: 12pt; font-weight: bold;">递增版本号 的&nbsp;&nbsp;作用范围一定程度上决定了 事务是什么级别的事务</span><span style="font-size: 12pt;">，比如HBase是 Region级别的 递增版本号，那么 事务就是region级别事务。MySQL中版本是单机递增版本，那么MySQL事务就支持单机跨行事务。Percolator中版本是集群递增版本，那么Percolator事务就是分布式事务。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因此，在分布式数据库中，</span><span style="font-size: 12pt;">一个&nbsp;&nbsp;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">统一高可用的发号器</span><span style="font-size: 12pt;">&nbsp;&nbsp;来做 版本号的递增&nbsp;&nbsp;是实现&nbsp;&nbsp;分布式事务的关键</span><span style="font-size: 12pt;">。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">问题：</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">Spanner</span>&nbsp;&nbsp;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">如何&nbsp;&nbsp;实现&nbsp;&nbsp;跨机房的&nbsp;&nbsp;唯一递增版本号？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在google&nbsp;&nbsp;的&nbsp;&nbsp;Spanner&nbsp;&nbsp;中，</span><span style="font-size: 12pt; color: unset; font-family: unset;">存在两个 level&nbsp;&nbsp;的&nbsp;&nbsp;发号器：</span></div><div><font style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt;">在每个机房都 有一个&nbsp;&nbsp;中心发号器，该机房的节点&nbsp;&nbsp;处理的事务&nbsp;&nbsp;请求都要&nbsp;&nbsp;来这里&nbsp;&nbsp;拿一个 唯一的递增版本号。这个中心发号器&nbsp;&nbsp;自身&nbsp;&nbsp;也可以做成 分布式的，并采用分布一致性算法&nbsp;&nbsp;保证&nbsp;&nbsp;版本号唯一且递增（&nbsp;&nbsp;例如&nbsp;&nbsp; zookeeper&nbsp;&nbsp;的&nbsp;&nbsp;临时递增节点 ）</span></div></li></ul><div><span style="font-size: 12pt;">&nbsp;&nbsp;</span></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">分布在全球各个&nbsp;&nbsp;机房 中的集群 都有 一个 原子钟，在初始化 校准后 ，所有机房的原子钟 都是同步的（误差很小&nbsp;&nbsp;且能&nbsp;&nbsp;确定误差的范围）。</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因此Spanner&nbsp;&nbsp;可以&nbsp;&nbsp;实现&nbsp;&nbsp; 全球所有&nbsp;&nbsp;机房中的&nbsp;&nbsp;所有节点的&nbsp;&nbsp;&nbsp;&nbsp;版本的递增，也就实现了&nbsp;&nbsp;全球 的 分布式事务，&nbsp;&nbsp;全球的所有节点可以 作为&nbsp;&nbsp;一个&nbsp;&nbsp;统一的分布式数据库 使用。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在&nbsp;&nbsp;OceanBase 中，有 3个节点 组成的NTP 服务 来做 发号器，由NTP服务保证 3个节点的时钟同步，因为 时钟的精度可以达到 ns ，即 1 s 可以发 10^9 个号，足以满足 高并发事务的要求；若 有1台 服务器宕机，NTP 服务 会将时钟 整体向后漂移 一段时间，保证 发放的 版本号 一定随时间递增，不会出现时光倒流。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">问题：</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">OceanBase</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">为何&nbsp;&nbsp;只有&nbsp;&nbsp;可串行化&nbsp;&nbsp;和&nbsp;&nbsp;读已提交&nbsp;&nbsp;两种隔离级别？（</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">对比&nbsp;&nbsp;&nbsp;&nbsp;OceanBase 和 DB2&nbsp;&nbsp;&nbsp;&nbsp;中 事务的隔离级别</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset;">）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1.OB&nbsp;&nbsp;采用 MVCC&nbsp;&nbsp;的方法：</span></div><ul><li><div><span style="font-size: 12pt;">对于&nbsp;&nbsp;写事务，在事务 提交 之后 发一个&nbsp;&nbsp;时间戳作为&nbsp;&nbsp; 发生更新数据的版本号</span></div></li><li><div><span style="font-size: 12pt;">对于读事务，</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果隔离&nbsp;&nbsp;级别设定为&nbsp;&nbsp;可串行化，那么&nbsp;&nbsp;在整个读事务&nbsp;&nbsp;的周期中，所有的读取 都使用&nbsp;&nbsp;第一次读取&nbsp;&nbsp;拿到的版本号，即读取 只能读到&nbsp;&nbsp;更新时间 <=&nbsp;&nbsp;版本号&nbsp;&nbsp;的行 ，这样&nbsp;&nbsp;可以避免&nbsp;&nbsp;幻读（幻读一定是在我读事务的周期里更新了数据，并且更新的这一行数据有一个更大的版本号）； </span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></div><div><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp;&nbsp; 如果&nbsp;&nbsp;隔离&nbsp;&nbsp;&nbsp;&nbsp;级别设定为&nbsp;&nbsp; 读已提交，那么&nbsp;&nbsp;在整个读事务&nbsp;&nbsp;的周期中，每一次&nbsp;&nbsp;读取&nbsp;&nbsp;都拿一个&nbsp;&nbsp;新的版本号，这样就会出现&nbsp;&nbsp;每次读取&nbsp;&nbsp;所能看到的 数据版本&nbsp;&nbsp;可能不一样（不可重复读现象） </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">2.OB&nbsp;&nbsp;的&nbsp;&nbsp;更新策略 采用&nbsp;&nbsp; “在commit&nbsp;&nbsp;开始之后&nbsp;&nbsp;才把&nbsp;&nbsp;更新写入数据库”，即&nbsp;&nbsp;遵从&nbsp;&nbsp;commit rule&nbsp;&nbsp;在提交之前&nbsp;&nbsp;先将&nbsp;&nbsp;新的值写入log&nbsp;&nbsp;中，恢复的&nbsp;&nbsp;时候&nbsp;&nbsp;使用&nbsp;&nbsp;日志中的&nbsp;&nbsp;新值&nbsp;&nbsp;去redo</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">3. OB&nbsp;&nbsp;采用&nbsp;&nbsp;主从结构，从节点&nbsp;&nbsp;中存着&nbsp;&nbsp;主节点&nbsp;&nbsp;数据的副本，为了保持&nbsp;&nbsp;一致性，读和写&nbsp;&nbsp;都请求的是主节点。</span></div><ul><li><div><span style="font-size: 12pt;">如果&nbsp;&nbsp;新数据 在主节点&nbsp;&nbsp;成功写入，那么&nbsp;&nbsp; 将 同步复制（主节点&nbsp;&nbsp;要收到&nbsp;&nbsp;从节点&nbsp;&nbsp;的写入&nbsp;&nbsp;成功的 ACK ） 到 n&nbsp;&nbsp;个&nbsp;&nbsp;从节点中（n+1 >= N/2&nbsp;&nbsp; ，N为&nbsp;&nbsp;总的副本数）</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">4.读写&nbsp;&nbsp;都是主节点&nbsp;&nbsp;导致&nbsp;&nbsp;主节点&nbsp;&nbsp;压力过大，OB&nbsp;&nbsp;采用了&nbsp;&nbsp;互为主备的方法：</span></div><div><div><font style="font-size: 12pt;"><br/></font></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"/><col style="width: 130px;"/><col style="width: 130px;"/></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">节点1</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">节点2&nbsp;&nbsp;</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">节点3</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">A库&nbsp;&nbsp;主</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">A库&nbsp;&nbsp;副本1</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">A库&nbsp;&nbsp;副本2</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">B库&nbsp;&nbsp;副本1</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">B库&nbsp;&nbsp;主</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">B库&nbsp;&nbsp;副本2</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">C库&nbsp;&nbsp;副本1</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">C库&nbsp;&nbsp;副本2</span></div></td><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">C库&nbsp;&nbsp;主</span></div></td></tr></tbody></table><div><span style="font-size: 12pt;">问题来了，请求 A&nbsp;&nbsp;库中的数据，我怎么知道 A库的主节点是哪个：每个节点 都有一张路由表，记录&nbsp;&nbsp;哪个库的&nbsp;&nbsp;主节点是谁，如果来了请求，发现&nbsp;&nbsp;主节点不是我，我把请求路由走</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">问题：DB2&nbsp;&nbsp; 如何&nbsp;&nbsp;做到&nbsp;&nbsp; 4&nbsp;&nbsp;种隔离级别&nbsp;&nbsp;都支持</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1.采用&nbsp;&nbsp;锁机制，但是它的锁很复杂：有写锁，还有读锁；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于读锁，有 范围读锁，比如&nbsp;&nbsp;一个读事务：select *from A where date > 2020-06-01&nbsp;&nbsp;那么&nbsp;&nbsp;读锁会把&nbsp;&nbsp;表中&nbsp;&nbsp;满足 date > 2020-06-01&nbsp;&nbsp;行 全部锁起来&nbsp;&nbsp;不让别人写，这样就不会出现&nbsp;&nbsp;读取到一半&nbsp;&nbsp;内容被人修改的情况。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3.</span><span style="font-size: 12pt; font-weight: bold;">事务持久性&nbsp;&nbsp;</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HBase事务持久化可以理解为WAL持久化，目前实现了多种持久化策略：SKIP_WAL，ASYNC_WAL，SYNC_WAL，FSYNC_WAL。</span></div><ul><li><div><span style="font-size: 12pt;">SKIP_WAL 表示不写WAL，这样写入更新性能最好，但在RegionServer宕机的时候有可能会丢失部分数据；</span></div></li><li><div><span style="font-size: 12pt;">ASYNC_WAL 表示异步将WAL持久化到硬盘，因为是异步操作所以在异常的情况下也有可能丢失少量数据；</span></div></li><li><div><span style="font-size: 12pt;">SYNC_WAL 表示同步将WAL持久化到操作系统缓存，再由操作系统将数据异步持久化到磁盘，这种场景下RS宕掉并不会丢失数据，当操作系统宕掉会导致部分数据丢失；</span></div></li><li><div><span style="font-size: 12pt;">FSYNC_WAL 表示WAL写入之后立马落盘，性能相对最差。</span></div></li></ul><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">用户可以根据业务对数据丢失的敏感性在客户端配置相应的持久化策略。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">引用</span></div><div><a target="_blank" rel="noopener" href="http://hbasefly.com/2017/07/26/transaction-2/" style="font-size: 12pt;">http://hbasefly.com/2017/07/26/transaction-2/</a></div><div><a target="_blank" rel="noopener" href="http://hbasefly.com/2017/08/19/mysql-transaction/" style="font-size: 12pt;">http://hbasefly.com/2017/08/19/mysql-transaction/</a></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><div><br/></div></body></html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io">Xinrihui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xinrihui.github.io/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/">https://xinrihui.github.io/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HBase/">HBase</a><a class="post-meta__tags" href="/tags/%E4%BA%8B%E5%8A%A1/">事务</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">数据结构-查找</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/24/MPP%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MPP 数据库原理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xinrihui</div><div class="author-info__description">一个计算机民间爱好者的关于算法，分布式系统和机器学习的笔记，欢迎大佬拍砖交流～。笔者曾在微软亚洲研究院实习，参与国家重点研发计划，兴趣为分布式系统和机器学习。转载请注明引用（应该也没人看 ==），邮箱 xinrihui@outlook.com</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">33</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinrihui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/25/1.shuffle%20%E7%A0%94%E7%A9%B6/" title="Spark shuffle 机制"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark shuffle 机制"/></a><div class="content"><a class="title" href="/2022/12/25/1.shuffle%20%E7%A0%94%E7%A9%B6/" title="Spark shuffle 机制">Spark shuffle 机制</a><time datetime="2022-12-25T01:54:24.000Z" title="Created 2022-12-25 09:54:24">2022-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/25/2.RDD%20%E7%AE%97%E5%AD%90/" title="Spark RDD 算子"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spark RDD 算子"/></a><div class="content"><a class="title" href="/2022/12/25/2.RDD%20%E7%AE%97%E5%AD%90/" title="Spark RDD 算子">Spark RDD 算子</a><time datetime="2022-12-25T01:54:24.000Z" title="Created 2022-12-25 09:54:24">2022-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%20-%E6%95%B0%E6%8D%AEsense/" title="计算机组成原理 -数据sense"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成原理 -数据sense"/></a><div class="content"><a class="title" href="/2022/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%20-%E6%95%B0%E6%8D%AEsense/" title="计算机组成原理 -数据sense">计算机组成原理 -数据sense</a><time datetime="2022-12-24T16:17:10.000Z" title="Created 2022-12-25 00:17:10">2022-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/" title="数据结构-查找"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构-查找"/></a><div class="content"><a class="title" href="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/" title="数据结构-查找">数据结构-查找</a><time datetime="2022-12-24T16:04:51.000Z" title="Created 2022-12-25 00:04:51">2022-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/" title="HBase - 事务"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HBase - 事务"/></a><div class="content"><a class="title" href="/2022/12/24/HBase%20%E5%8E%9F%E7%90%864%EF%BC%9A%E4%BA%8B%E5%8A%A1/" title="HBase - 事务">HBase - 事务</a><time datetime="2022-12-24T15:40:19.000Z" title="Created 2022-12-24 23:40:19">2022-12-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Xinrihui</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>